{% load static %}
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AI健康顾问 - 智能助手</title>
    <link rel="stylesheet" href="{% static 'css/all.min.css' %}">
    <link rel="stylesheet" href="{% static 'css/modern-theme.css' %}">
     <script src="{% static 'js/marked.min.js' %}"></script>
    <style>


        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'PingFang SC', 'Helvetica Neue', Arial, sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* 允许文本选择的元素 */
        .text-input,
        .message,
        input[type="text"],
        input[type="password"] {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
            -webkit-touch-callout: default;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            background: linear-gradient(145deg, #E3F2FD 0%, #FFFFFF 50%, #E8F5E9 100%);
            color: var(--gray-800);
            font-size: 15px;
            line-height: 1.6;
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }



        

        /* ===== 主容器样式 ===== */
        .container {
            width: 100%;
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100);
            background: transparent;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            padding-top: 64px;
            padding-bottom: 76px;
            animation: fadeIn 0.8s ease forwards;
        }

        /* ===== AI对话区域样式 ===== */
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin: 15px;
            background: var(--surface);
            border-radius: 20px;
            box-shadow: var(--shadow-card);
            border: 1px solid rgba(74, 144, 226, 0.08);
            background-image: linear-gradient(to bottom right, var(--surface), var(--surface-soft));
            overflow: hidden;
            min-height: 0; /* 确保flex子元素可以收缩 */
            animation: fadeIn 0.6s ease forwards;
        }

        .chat-header {
            padding: 20px;
            border-bottom: 1px solid rgba(74, 144, 226, 0.08);
            background: var(--surface-soft);
        }

        .chat-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--primary-deep);
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .chat-status {
            display: flex;
            align-items: center;
            gap: 20px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--error);
        }

        .status-dot.connected {
            background: var(--success);
        }

        .status-dot.connecting {
            background: var(--warning);
            animation: pulse 1.5s infinite;
        }

        /* ===== 对话区域样式 ===== */
        .conversation-area {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-height: 0; /* 确保可以收缩 */
            max-height: calc(var(--vh, 1vh) * 100 - 300px); /* 使用动态视口高度 */
        }

        /* 移动端滚动条隐藏 */
        @media (max-width: 768px) {
            .conversation-area::-webkit-scrollbar {
                width: 0px;
                background: transparent;
            }
            
            .chat-container {
                height: calc(var(--vh, 1vh) * 100);
            max-height: calc(var(--vh, 1vh) * 100);
            }
            
            /* 强制设置对话区域的最大高度 */
            .conversation-area {
                height: auto;
                max-height: calc(var(--vh, 1vh) * 100 - 150px);
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
        }

        .message {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 18px;
            box-shadow: var(--shadow-soft);
            animation: slideInUp 0.3s ease;
        }
        
        /* 消息内容容器 */
        .message-content {
            width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .message.user {
            background: linear-gradient(135deg, var(--primary-deep), var(--primary-light));
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 6px;
        }

        .message.ai {
            background: var(--surface-soft);
            border: 1px solid rgba(74, 144, 226, 0.08);
            color: var(--text-primary);
            margin-right: auto;
            border-bottom-left-radius: 6px;
        }

        .message-time {
            font-size: 0.75rem;
            opacity: 0.7;
            margin-top: 4px;
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: var(--surface-soft);
            border-radius: 18px;
            border-bottom-left-radius: 6px;
            max-width: 80px;
            margin-right: auto;
            box-shadow: var(--shadow-soft);
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--text-muted);
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.4;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        /* ===== 输入提示区域样式 ===== */
        .input-hint-area {
            padding: 10px 20px 0px 20px;
            text-align: center;
        }

        .input-hint {
            display: inline-block;
            padding: 6px 16px;
            background: var(--surface-soft);
            color: var(--text-muted);
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: var(--shadow-soft);
            transition: all 0.3s ease;
        }

        /* ===== 输入区域样式 ===== */
        .input-area {
            padding: var(--space-5);
            border-top: 1px solid var(--gray-200);
            background: var(--white);
            box-shadow: 0 -4px 16px rgba(0, 0, 0, 0.04);
        }

        .input-tabs {
            display: flex;
            margin-bottom: var(--space-4);
            background: var(--gray-100);
            border-radius: var(--radius-xl);
            padding: var(--space-1);
            border: 1px solid var(--gray-200);
        }

        .input-tab {
            flex: 1;
            padding: var(--space-2) var(--space-4);
            border: none;
            background: none;
            border-radius: var(--radius-lg);
            cursor: pointer;
            transition: all var(--transition-base);
            font-weight: 600;
            color: var(--gray-600);
            font-size: 0.875rem;
        }

        .input-tab.active {
            background: var(--white);
            color: var(--primary-blue);
            box-shadow: var(--shadow-sm);
        }

        .input-content {
            display: none;
        }

        .input-content.active {
            display: block;
        }

        .text-input-area {
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }

        .text-input {
            flex: 1;
            padding: var(--space-3) var(--space-4);
            border: 2px solid var(--gray-200);
            border-radius: var(--radius-2xl);
            background: var(--white);
            color: var(--gray-800);
            resize: none;
            min-height: 48px;
            max-height: 120px;
            transition: all var(--transition-base);
            font-family: inherit;
            font-size: 0.9375rem;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .text-input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 4px var(--primary-pale);
            -webkit-tap-highlight-color: transparent;
        }

        /* 移动端输入框优化 */
        @media (max-width: 768px) {
            .text-input {
                font-size: 16px; /* 防止iOS缩放 */
                -webkit-user-select: text;
                user-select: text;
                -webkit-touch-callout: default;
            }
        }

        .send-button {
            width: 48px;
            height: 48px;
            border: none;
            border-radius: 50%;
            background: var(--gradient-primary);
            color: white;
            cursor: pointer;
            transition: all var(--transition-base);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-md);
        }

        .send-button:hover:not(:disabled) {
            transform: scale(1.1);
            box-shadow: var(--shadow-lg);
        }

        .send-button:active:not(:disabled) {
            transform: scale(0.95);
        }

        .send-button:disabled {
            background: var(--gray-300);
            cursor: not-allowed;
            transform: none;
        }

        .voice-input-area {
            text-align: center;
        }

        .record-button {
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--error), #c0392b);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            margin: 0 auto 15px;
            box-shadow: var(--shadow-card);
            text-align: center;
            line-height: 1.1;
            padding: 2px;
        }

        .record-button:hover:not(:disabled) {
            background: linear-gradient(135deg, #c0392b, #a93226);
            transform: scale(1.05);
        }

        .record-button:active:not(:disabled) {
            background: linear-gradient(135deg, #a93226, #922b21);
            transform: scale(0.95);
        }

        .record-button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
        }

        .record-button.recording {
            animation: recordPulse 1.5s infinite;
        }

        @keyframes recordPulse {
            0% {
                background: linear-gradient(135deg, var(--error), #c0392b);
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7);
            }
            50% {
                background: linear-gradient(135deg, #ff6b6b, var(--error));
                box-shadow: 0 0 0 20px rgba(231, 76, 60, 0);
            }
            100% {
                background: linear-gradient(135deg, var(--error), #c0392b);
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0);
            }
        }

        .audio-visualizer {
            height: 60px;
            width: 100%;
            border: 1px solid rgba(74, 144, 226, 0.2);
            border-radius: 12px;
            background: var(--surface-soft);
            display: none;
        }

        /* ===== 设置面板样式 ===== */
        .settings-panel {
                position: fixed;
                top: 0;
                right: -400px;
                width: 380px;
                height: calc(100vh - 60px);
                background: var(--surface);
                border-left: 1px solid rgba(74, 144, 226, 0.08);
                box-shadow: var(--shadow-card);
                transition: right 0.3s ease;
                z-index: 99;
                overflow-y: auto;
            }

        .settings-panel.open {
            right: 0;
        }

        .settings-header {
            padding: 20px;
            border-bottom: 1px solid rgba(74, 144, 226, 0.08);
            background: var(--surface-soft);
        }

        .settings-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--primary-deep);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .settings-content {
            padding: 20px;
        }

        .setting-group {
            margin-bottom: 25px;
        }

        .setting-group h3 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-item {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .setting-item label {
            width: 100px;
            text-align: right;
            margin-right: 15px;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.9rem;
        }

        .setting-item input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid rgba(74, 144, 226, 0.2);
            border-radius: 8px;
            background: var(--surface);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .setting-item input:focus {
            outline: none;
            border-color: var(--primary-light);
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        .connect-button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--primary-deep), var(--primary-dark));
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            margin-top: 15px;
        }

        .connect-button:hover {
            background: linear-gradient(135deg, var(--primary-light), var(--primary-deep));
            transform: translateY(-2px);
            box-shadow: var(--shadow-hover);
        }

        /* 清空聊天记录按钮样式 */
        .clear-chat-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 16px;
            background: rgba(231, 76, 60, 0.1);
            color: var(--error);
            border: 1px solid rgba(231, 76, 60, 0.2);
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .clear-chat-btn:hover {
            background: rgba(231, 76, 60, 0.15);
            border-color: rgba(231, 76, 60, 0.3);
            transform: translateY(-1px);
        }

        .clear-chat-btn:active {
            transform: translateY(0);
        }

        .clear-chat-btn i {
            font-size: 0.9rem;
        }

        /* 设置描述文本样式 */
        .setting-description {
            font-size: 0.8rem;
            color: var(--text-muted);
            line-height: 1.4;
            margin-top: 8px;
            padding: 8px 12px;
            background: rgba(74, 144, 226, 0.05);
            border-radius: 6px;
            border-left: 3px solid rgba(231, 76, 60, 0.3);
        }

        /* 麦克风教程样式 */
        .mic-tutorial {
            margin-top: 20px;
            padding: 15px;
            background: rgba(52, 152, 219, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(52, 152, 219, 0.2);
        }

        .mic-tutorial h4 {
            color: var(--primary-deep);
            font-size: 1rem;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mic-tutorial .problem-item {
            margin-bottom: 15px;
            padding: 10px;
            background: var(--surface);
            border-radius: 8px;
            border-left: 3px solid var(--warning);
        }

        .mic-tutorial .problem-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 6px;
            font-size: 0.9rem;
        }

        .mic-tutorial .solution {
            color: var(--text-secondary);
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .mic-tutorial .solution ol {
            margin-left: 20px;
            margin-top: 5px;
        }

        .mic-tutorial .solution li {
            margin-bottom: 4px;
        }

        .mic-status-btn {
            display: inline-block;
            padding: 6px 12px;
            background: var(--primary-light);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            margin-top: 8px;
            transition: all 0.3s ease;
        }

        .mic-status-btn:hover {
            background: var(--primary-deep);
            transform: translateY(-1px);
        }

        /* 为页面内容添加底部间距 */
        .main-content {
            padding-top: calc(70px + env(safe-area-inset-top));
            padding-bottom: calc(80px + env(safe-area-inset-bottom));
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            min-height: 100vh;
            min-height: 100dvh;
        }

        /* ===== 动画效果 ===== */
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        .fade-in {
            animation: fadeIn 0.6s ease forwards;
        }

        .slide-in-up {
            animation: slideInUp 0.6s ease forwards;
        }

        /* ===== 响应式设计 ===== */
        @media (max-width: 768px) {

            

            
            /* 主容器优化 */
            .container {
                width: 100%;
                height: 100vh;
                padding-top: 60px;
                background: transparent;
                position: relative;
                overflow-y: auto;
                overflow-x: hidden;
            }
            
            /* 对话容器优化 */
            .chat-container {
                margin: 10px;
                margin-bottom: 15px;
                border-radius: 15px;
            }
            
            .chat-header {
                padding: 15px;
            }
            
            .chat-title {
                font-size: 1.1rem;
            }
            
            .chat-status {
                font-size: 0.8rem;
                gap: 15px;
            }
            
            /* 对话区域优化 */
            .conversation-area {
                padding: 15px;
                gap: 12px;
                max-height: calc(var(--vh, 1vh) * 100 - 280px); /* 移动端使用动态视口高度 */
            }
            
            .message {
                max-width: 85%;
                padding: 10px 14px;
                font-size: 0.9rem;
                border-radius: 16px;
            }
            
            .message.user {
                border-bottom-right-radius: 4px;
            }
            
            .message.ai {
                border-bottom-left-radius: 4px;
            }
            
            .message-time {
                font-size: 0.7rem;
            }
            
            /* 输入区域优化 */
            .input-area {
                padding: 15px;
                padding-bottom: 20px;
            }
            
            .input-tabs {
                margin-bottom: 12px;
                padding: 3px;
            }
            
            .input-tab {
                padding: 6px 12px;
                font-size: 0.85rem;
            }
            
            .text-input-area {
                gap: 10px;
            }
            
            .text-input {
                padding: 10px 14px;
                font-size: 0.9rem;
                min-height: 40px;
                max-height: 100px;
            }
            
            .send-button {
                width: 40px;
                height: 40px;
                font-size: 0.9rem;
            }
            
            .record-button {
                width: 50px;
                height: 50px;
                font-size: 0.7rem;
                margin-bottom: 12px;
            }
            
            /* 设置面板优化 */
            .settings-panel {
                width: 100%;
                right: -100%;
                top: 50px;
                height: calc(100vh - 110px);
            }
            
            .settings-header {
                padding: 15px;
            }
            
            .settings-title {
                font-size: 1rem;
            }
            
            .settings-content {
                padding: 15px;
            }
            
            .setting-group {
                margin-bottom: 20px;
            }
            
            .setting-group h3 {
                font-size: 0.95rem;
                margin-bottom: 12px;
            }
            
            .setting-item {
                flex-direction: column;
                align-items: stretch;
                margin-bottom: 10px;
            }
            
            .setting-item label {
                width: auto;
                text-align: left;
                margin-right: 0;
                margin-bottom: 5px;
                font-size: 0.85rem;
            }
            
            .setting-item input {
                font-size: 0.9rem;
                padding: 10px 12px;
            }
            
            .connect-button {
                padding: 10px;
                font-size: 0.9rem;
                margin-top: 12px;
            }
            
            /* 欢迎消息优化 */
            .welcome-message {
                padding: 30px 15px;
            }
            
            .welcome-message i {
                font-size: 2.5rem;
                margin-bottom: 12px;
            }
            
            .welcome-message h3 {
                font-size: 1.1rem;
                margin-bottom: 6px;
            }
            
            .welcome-message p {
                font-size: 0.9rem;
            }
            
            /* 状态指示器优化 */
            #scriptStatus {
                padding: 15px 20px;
                font-size: 0.9rem;
                border-radius: 12px;
                max-width: 90%;
                text-align: center;
            }
            
            /* 音频可视化器优化 */
            .audio-visualizer {
                height: 50px;
                border-radius: 10px;
            }
            
            /* 打字指示器优化 */
            .typing-indicator {
                padding: 10px 14px;
                max-width: 70px;
            }
            
            .typing-dot {
                width: 5px;
                height: 5px;
            }
        }
        
        /* 小屏幕设备进一步优化 */
        @media (max-width: 480px) {
            .top-header {
                height: 45px;
                padding: 0 12px;
            }
            
            .header-logo {
                width: 28px;
                height: 28px;
                font-size: 0.9rem;
            }
            
            .header-title {
                font-size: 0.8rem;
            }
            
            .header-icon {
                width: 28px;
                height: 28px;
                font-size: 0.9rem;
            }
            
            .container {
                padding-top: calc(45px + env(safe-area-inset-top));
            }
            
            .chat-container {
                margin: 8px;
            }
            
            .message {
                max-width: 90%;
                padding: 8px 12px;
                font-size: 0.85rem;
            }
            
            .text-input {
                font-size: 0.85rem;
                padding: 8px 12px;
            }
            
            .send-button {
                width: 36px;
                height: 36px;
            }
            
            .record-button {
                width: 45px;
                height: 45px;
                font-size: 0.65rem;
            }
        }
        
        /* 横屏模式优化 */
        @media (max-width: 768px) and (orientation: landscape) {
            .top-header {
                height: 45px;
            }
            
            .container {
                padding-top: calc(45px + env(safe-area-inset-top));
            }
            
            .chat-header {
                padding: 12px 15px;
            }
            
            .conversation-area {
                padding: 12px 15px;
                max-height: calc(var(--vh, 1vh) * 100 - 250px); /* 横屏模式使用动态视口高度 */
            }
            
            .input-area {
                padding: 12px 15px;
            }
            
            .nav-item {
                padding: 4px 6px;
            }
            
            .nav-icon {
                margin-bottom: 1px;
            }
        }

        /* ===== 加载状态 ===== */
        #scriptStatus {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 30px;
            border-radius: 16px;
            font-weight: 600;
            box-shadow: var(--shadow-card);
            z-index: 1000;
            background: var(--surface);
            color: var(--primary-deep);
            border: 2px solid var(--primary-light);
        }

        .welcome-message {
            text-align: left;
            padding: 5px 15px;
            color: var(--text-muted);
        }

        .welcome-message i {
            font-size: 3rem;
            color: var(--primary-light);
            margin-bottom: 15px;
        }

        .welcome-message h3 {
            font-size: 1.2rem;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        /* ===== 快捷按钮样式 ===== */
        .quick-button {
            padding: 6px 12px;
            border: 1px solid var(--primary-light);
            border-radius: 16px;
            background: var(--surface);
            color: var(--primary-deep);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
            font-weight: 500;
            box-shadow: none;
            white-space: nowrap;
            border: 1px solid rgba(99, 102, 241, 0.3);
        }

        .quick-button:hover {
            background: linear-gradient(135deg, var(--primary-light), var(--primary-deep));
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }

        .quick-button:active {
            transform: translateY(0);
            box-shadow: none;
        }
        
        /* 消息内的快捷按钮容器 */
        .message .quick-buttons {
            margin-top: 12px !important;
            padding: 8px 0 0 0;
            border-top: 1px solid rgba(99, 102, 241, 0.1);
        }
        
        /* ===== Markdown样式支持 ===== */
        .message h1, .message h2, .message h3, .message h4, .message h5, .message h6 {
            margin: 8px 0;
            color: inherit;
            font-weight: 600;
            line-height: 1.4;
        }
        
        .message h1 { font-size: 1.4em; }
        .message h2 { font-size: 1.3em; }
        .message h3 { font-size: 1.2em; }
        .message h4 { font-size: 1.1em; }
        .message h5 { font-size: 1.05em; }
        .message h6 { font-size: 1em; }
        
        .message p {
            margin: 6px 0;
            line-height: 1.5;
        }
        
        .message ul, .message ol {
            margin: 6px 0;
            padding-left: 20px;
        }
        
        .message li {
            margin: 3px 0;
            line-height: 1.4;
        }
        
        .message blockquote {
            margin: 8px 0;
            padding: 8px 12px;
            border-left: 3px solid var(--primary-light);
            background: rgba(74, 144, 226, 0.05);
            border-radius: 0 8px 8px 0;
            font-style: italic;
        }
        
        .message code {
            background: rgba(74, 144, 226, 0.1);
            padding: 2px 4px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--primary-deep);
        }
        
        .message pre {
            background: rgba(74, 144, 226, 0.05);
            border: 1px solid rgba(74, 144, 226, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.4;
        }
        
        .message pre code {
            background: none;
            padding: 0;
            color: inherit;
        }
        
        .message table {
            width: 100%;
            border-collapse: collapse;
            margin: 8px 0;
            font-size: 0.9em;
        }
        
        .message th, .message td {
            border: 1px solid rgba(74, 144, 226, 0.2);
            padding: 6px 8px;
            text-align: left;
        }
        
        .message th {
            background: rgba(74, 144, 226, 0.1);
            font-weight: 600;
        }
        
        .message tr:nth-child(even) {
            background: rgba(74, 144, 226, 0.02);
        }
        
        .message a {
            color: var(--primary-light);
            text-decoration: none;
            border-bottom: 1px dotted transparent;
            transition: all 0.3s ease;
        }
        
        .message a:hover {
            border-bottom-color: var(--primary-light);
            text-decoration: underline;
        }
        
        .message strong {
            font-weight: 600;
            color: inherit;
        }
        
        .message em {
            font-style: italic;
            color: inherit;
        }
        
        .message hr {
            border: none;
            height: 1px;
            background: rgba(74, 144, 226, 0.2);
            margin: 12px 0;
        }
        
        .message img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 8px 0;
        }
        
        /* 用户消息中的Markdown样式调整 */
        .message.user h1, .message.user h2, .message.user h3, 
        .message.user h4, .message.user h5, .message.user h6 {
            color: rgba(255, 255, 255, 0.95);
        }
        
        .message.user blockquote {
            border-left-color: rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .message.user code {
            background: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.95);
        }
        
        .message.user pre {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .message.user pre code {
            color: rgba(255, 255, 255, 0.95);
        }
        
        .message.user th, .message.user td {
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .message.user th {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .message.user tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .message.user a {
            color: rgba(255, 255, 255, 0.9);
        }
        
        .message.user a:hover {
            border-bottom-color: rgba(255, 255, 255, 0.9);
        }
        
        .message.user hr {
            background: rgba(255, 255, 255, 0.3);
        }


    </style>
</head>
<body>

    <!-- 顶部栏 -->
    <div class="top-header">
        <div class="header-right">
            <div class="header-icon" id="settingsBtn">
                <i class="fas fa-cog"></i>
            </div>
        </div>
    </div>

    <!-- 主容器 -->
    <div class="container">
        <!-- AI对话区域 -->
        <div class="chat-container">
            <!-- 对话头部 (已隐藏) -->
            <div class="chat-header" style="display: none;">
                <div class="chat-title">
                    开发模式
                </div>
                <div class="chat-status">
                    <div class="status-indicator">
                        <span>WebSocket: <span id="connectionStatus">未连接</span></span>
                    </div>
                    <div class="status-indicator">
                        <span>OTA: <span id="otaStatus">未连接</span></span>
                    </div>
                </div>
            </div>

            <!-- 对话区域 -->
            <div class="conversation-area" id="conversationArea">
                <div class="message ai welcome-message">
                    <div class="message-content">**{{user_name}}我是您的 AI营养顾问**

请问我有什么可以帮到您的吗？

我可以为您提供以下服务：

**营养咨询** - 个性化饮食建议     

**健康分析** - 基于数据的健康评估         

**健身指导** - 科学运动方案

**食谱推荐** - 健康美味菜谱</div>
                    <div class="message-time">刚刚</div>
                    
                    <!-- 快捷按钮区域 -->
                    <div class="quick-buttons" style="margin-top: 15px; display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-start;">
                        <button class="quick-button" onclick="sendQuickMessage('我想健康增脂')">我想健康增脂</button>
                        <button class="quick-button" onclick="sendQuickMessage('我想健康减肥')">我想健康减肥</button>
                        <button class="quick-button" onclick="sendQuickMessage('我想均衡饮食')">我想均衡饮食</button>
                        <button class="quick-button" onclick="sendQuickMessage('我应该怎么吃')">我应该怎么吃</button>
                        <button class="quick-button" onclick="sendQuickMessage('{{user_name}}从数据库中查询我的饮食习惯')">从数据库中查询我的饮食习惯</button>
                    </div>
                </div>
            </div>

            <!-- 输入提示区域 -->
            <div class="input-hint-area" id="inputHintArea">
                <div class="input-hint" id="inputHint">点击文本框输入</div>
            </div>

            <!-- 输入区域 -->
            <div class="input-area">
                <div class="input-tabs">
                    <button class="input-tab active" data-tab="text">
                        <i class="fas fa-keyboard"></i> 文本输入
                    </button>
                    <button class="input-tab" data-tab="voice">
                        <i class="fas fa-microphone"></i> 语音输入
                    </button>
                </div>

                <div class="input-content active" id="textInputContent">
                    <div class="text-input-area">
                        <textarea class="text-input" id="messageInput" placeholder="开始质询 AI 健康顾问..." disabled rows="1"></textarea>
                        <button class="send-button" id="sendTextButton" disabled>
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                </div>

                <div class="input-content" id="voiceInputContent">
                    <div class="voice-input-area">
                        <button class="record-button" id="recordButton" disabled>
                            <i class="fas fa-microphone"></i>
                        </button>
                        <canvas class="audio-visualizer" id="audioVisualizer"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 设置面板 -->
    <div class="settings-panel" id="settingsPanel">
        <div class="settings-header">
            <div class="settings-title">
                <i class="fas fa-cog"></i>
                连接设置
            </div>
        </div>
        <div class="settings-content">
            <div class="setting-group">
                <h3><i class="fas fa-server"></i> 服务器配置</h3>
                <div class="setting-item">
                    <label>WebSocket:</label>
                    <input type="text" id="serverUrl" value="ws://172.16.65.200:8000/xiaozhi/v1/" placeholder="WebSocket服务器地址">
                </div>
                <div class="setting-item">
                    <label>OTA服务:</label>
                    <input type="text" id="otaUrl" value="http://172.16.65.200:8002/xiaozhi/ota/" placeholder="OTA服务器地址">
                </div>
                <button class="connect-button" id="connectButton">连接服务器</button>
            </div>

            <div class="setting-group">
                <h3><i class="fas fa-mobile-alt"></i> 设备信息</h3>
                <div class="setting-item">
                    <label>设备MAC:</label>
                    <input type="text" id="deviceMac" placeholder="设备MAC地址">
                </div>
                <div class="setting-item">
                    <label>设备名称:</label>
                    <input type="text" id="deviceName" value="Web测试设备" placeholder="设备名称">
                </div>
                <div class="setting-item">
                    <label>客户端ID:</label>
                    <input type="text" id="clientId" value="web_test_client" placeholder="客户端ID">
                </div>
                <div class="setting-item">
                    <label>认证Token:</label>
                    <input type="text" id="token" value="your-token1" placeholder="认证Token">
                </div>
                <button class="connect-button" id="authTestButton">测试认证</button>
            </div>

            <div class="setting-group">
                <h3><i class="fas fa-comments"></i> 聊天管理</h3>
                <div class="setting-item">
                    <label>清空聊天记录:</label>
                    <button class="clear-chat-btn" id="clearChatBtn" title="清空所有聊天记录">
                        <i class="fas fa-trash-alt"></i>
                        清空聊天记录
                    </button>
                </div>
                <div class="setting-description">
                    此操作将清空所有聊天记录。操作不可撤销！！
                </div>
            </div>

            <div class="setting-group">
                <h3><i class="fas fa-microphone"></i> 麦克风使用教程</h3>
                <div class="mic-tutorial">
                    <h4><i class="fas fa-question-circle"></i> 常见问题与解决方案</h4>
                    
                    <div class="problem-item">
                        <div class="problem-title">问题1：点击录音按钮没有反应</div>
                        <div class="solution">
                            <ol>
                                <li>检查浏览器是否支持WebRTC API（现代浏览器都支持）</li>
                                <li>确保网站是通过HTTPS协议访问的（HTTP环境下麦克风功能受限）</li>
                                <li>检查浏览器地址栏是否有麦克风权限请求图标</li>
                                <li>尝试刷新页面后重新授权</li>
                            </ol>
                        </div>
                    </div>
                    
                    <div class="problem-item">
                        <div class="problem-title">问题2：浏览器拒绝麦克风权限</div>
                        <div class="solution">
                            <ol>
                                <li>点击浏览器地址栏左侧的锁形图标或信息图标</li>
                                <li>在网站设置中找到"麦克风"选项</li>
                                <li>将权限设置为"允许"</li>
                                <li>刷新页面重新尝试</li>
                                <li>如果被永久阻止，需要在浏览器设置中清除网站数据</li>
                            </ol>
                        </div>
                    </div>
                    
                    <div class="problem-item">
                        <div class="problem-title">问题3：麦克风没有声音或声音很小</div>
                        <div class="solution">
                            <ol>
                                <li>检查系统音量设置，确保麦克风音量不是静音</li>
                                <li>检查物理麦克风是否连接正常</li>
                                <li>在系统声音设置中测试麦克风</li>
                                <li>尝试使用其他麦克风设备</li>
                                <li>检查是否有其他应用正在占用麦克风</li>
                            </ol>
                        </div>
                    </div>
                    
                    <div class="problem-item">
                        <div class="problem-title">问题4：录音时出现杂音或回声</div>
                        <div class="solution">
                            <ol>
                                <li>确保环境安静，远离噪音源</li>
                                <li>调整麦克风位置，避免对着扬声器</li>
                                <li>使用耳机避免回声</li>
                                <li>在系统设置中启用麦克风降噪功能</li>
                                <li>尝试降低麦克风增益</li>
                            </ol>
                        </div>
                    </div>
                    
                    <div class="problem-item">
                        <div class="problem-title">问题5：移动端麦克风问题</div>
                        <div class="solution">
                            <ol>
                                <li>确保iOS设备上使用Safari浏览器（其他浏览器可能不支持）</li>
                                <li>Android设备建议使用Chrome浏览器</li>
                                <li>检查手机是否静音模式</li>
                                <li>确保手机麦克风没有被物理遮挡</li>
                                <li>关闭其他可能使用麦克风的应用</li>
                            </ol>
                        </div>
                    </div>
                    
                    <button class="mic-status-btn" onclick="testMicrophone()">
                        <i class="fas fa-microphone-alt"></i> 测试麦克风
                    </button>
                    <div id="micTestResult" style="margin-top: 10px; font-size: 0.85rem; color: var(--text-secondary);"></div>
                </div>
            </div>
        </div>
    </div>



    <!-- 加载状态 -->
    <div id="scriptStatus">
        正在初始化AI助手...
    </div>

    
    <!-- Opus解码库 -->
    <script src="../static/js/libopus.js"></script>
    
    <script>
        // 需要加载的脚本列表 - 移除Opus依赖
        const scriptFiles = [];

        // 脚本加载状态
        const scriptStatus = {
            loading: 0,
            loaded: 0,
            failed: 0,
            total: scriptFiles.length
        };

        // 检查Opus库是否已加载
        function checkOpusLoaded() {
            try {
                // 检查Module是否存在（本地库导出的全局变量）
                if (typeof Module === 'undefined') {
                    throw new Error('Opus库未加载，Module对象不存在');
                }

                // 尝试先使用Module.instance（libopus.js最后一行导出方式）
                if (typeof Module.instance !== 'undefined' && typeof Module.instance._opus_decoder_get_size === 'function') {
                    // 使用Module.instance对象替换全局Module对象
                    window.ModuleInstance = Module.instance;
                    log('Opus库加载成功（使用Module.instance）', 'success');
                    updateScriptStatus('Opus库加载成功', 'success');

                    // 3秒后隐藏状态
                    const statusElement = document.getElementById('scriptStatus');
                    if (statusElement) statusElement.style.display = 'none';
                    return;
                }

                // 如果没有Module.instance，检查全局Module函数
                if (typeof Module._opus_decoder_get_size === 'function') {
                    window.ModuleInstance = Module;
                    log('Opus库加载成功（使用全局Module）', 'success');
                    updateScriptStatus('Opus库加载成功', 'success');

                    // 3秒后隐藏状态
                    const statusElement = document.getElementById('scriptStatus');
                    if (statusElement) statusElement.style.display = 'none';
                    return;
                }

                throw new Error('Opus解码函数未找到，可能Module结构不正确');
            } catch (err) {
                log(`Opus库加载失败，请检查libopus.js文件是否存在且正确: ${err.message}`, 'error');
                updateScriptStatus('Opus库加载失败，请检查libopus.js文件是否存在且正确', 'error');
            }
        }

        // 更新脚本状态显示
        function updateScriptStatus(message, type) {
            const statusElement = document.getElementById('scriptStatus');
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.className = `script-status ${type}`;
                statusElement.style.display = 'block';
                statusElement.style.width = 'auto';
            }
        }

        // 全局变量
        let websocket = null;
        let mediaRecorder = null;
        let audioContext = null;
        let analyser = null;
        let audioChunks = [];
        let isRecording = false;
        let visualizerCanvas = document.getElementById('audioVisualizer');
        let visualizerContext = visualizerCanvas.getContext('2d');
        let audioQueue = [];
        let isPlaying = false;
        let opusDecoder = null; // Opus解码器
        let visualizationRequest = null; // 动画帧请求ID

        // 音频流缓冲相关
        let audioBuffers = []; // 用于存储接收到的所有音频数据
        let totalAudioSize = 0; // 跟踪累积的音频大小

        let audioBufferQueue = [];     // 存储接收到的音频包
        let isAudioBuffering = false;  // 是否正在缓冲音频
        let isAudioPlaying = false;    // 是否正在播放音频
        const BUFFER_THRESHOLD = 3;    // 缓冲包数量阈值，至少累积3个包再开始播放
        const MIN_AUDIO_DURATION = 0.1; // 最小音频长度(秒)，小于这个长度的音频会被合并
        let streamingContext = null;   // 音频流上下文
        const SAMPLE_RATE = 16000;     // 采样率
        const CHANNELS = 1;            // 声道数
        const FRAME_SIZE = 960;        // 帧大小

        // DOM元素
        const connectButton = document.getElementById('connectButton');
        const serverUrlInput = document.getElementById('serverUrl');
        const connectionStatus = document.getElementById('connectionStatus');
        const otaStatus = document.getElementById('otaStatus');
        const messageInput = document.getElementById('messageInput');
        const sendTextButton = document.getElementById('sendTextButton');
        const recordButton = document.getElementById('recordButton');
        const stopButton = document.getElementById('stopButton');
        const conversationDiv = document.getElementById('conversationArea');
        const logContainer = document.createElement('div'); // 创建一个虚拟的日志容器

        // 提取Opus帧数据的函数
        function extractOpusFrames(webmData) {
            // 简单的WebM解析，提取Opus数据
            // 这是一个简化版本，实际的WebM解析会更复杂
            try {
                // 查找Opus数据的起始位置
                // WebM文件格式中，Opus数据通常在特定的位置
                let opusStart = -1;
                
                // 查找Opus编解码器标识
                for (let i = 0; i < webmData.length - 4; i++) {
                    // 查找可能的Opus数据块
                    if (webmData[i] === 0x4F && webmData[i + 1] === 0x70 && 
                        webmData[i + 2] === 0x75 && webmData[i + 3] === 0x73) {
                        opusStart = i;
                        break;
                    }
                }
                
                if (opusStart === -1) {
                    // 如果没有找到Opus标识，尝试跳过WebM头部
                    // 通常WebM头部在前几百字节
                    const headerSize = Math.min(1000, webmData.length);
                    return webmData.slice(headerSize);
                }
                
                // 从找到的位置开始提取数据
                return webmData.slice(opusStart);
            } catch (error) {
                log(`提取Opus帧失败: ${error.message}`, 'error');
                // 如果提取失败，返回原始数据
                return webmData;
            }
        }

        // 日志函数
        function log(message, type = 'info') {
            // 使用控制台输出日志，因为UI中没有专门的日志容器
            const timestamp = `[${new Date().toLocaleTimeString()}.${new Date().getMilliseconds().toString().padStart(3, '0')}]`;
            const logMessage = `${timestamp} ${message}`;
            
            // 根据类型输出到不同的控制台方法
            switch (type) {
                case 'error':
                    console.error(logMessage);
                    break;
                case 'warning':
                    console.warn(logMessage);
                    break;
                case 'success':
                    console.log(`%c${logMessage}`, 'color: green');
                    break;
                case 'debug':
                    console.debug(logMessage);
                    break;
                default:
                    console.log(logMessage);
            }
        }

        // 初始化可视化器
        function initVisualizer() {
            visualizerCanvas.width = visualizerCanvas.clientWidth;
            visualizerCanvas.height = visualizerCanvas.clientHeight;
            visualizerContext.fillStyle = '#fafafa';
            visualizerContext.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
        }

        // 绘制音频可视化效果
        function drawVisualizer(dataArray) {
            visualizationRequest = requestAnimationFrame(() => drawVisualizer(dataArray));

            if (!isRecording) return;

            analyser.getByteFrequencyData(dataArray);

            visualizerContext.fillStyle = '#fafafa';
            visualizerContext.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);

            const barWidth = (visualizerCanvas.width / dataArray.length) * 2.5;
            let barHeight;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                barHeight = dataArray[i] / 2;

                visualizerContext.fillStyle = `rgb(${barHeight + 100}, 50, 50)`;
                visualizerContext.fillRect(x, visualizerCanvas.height - barHeight, barWidth, barHeight);

                x += barWidth + 1;
            }
        }

        // 保存聊天记录到后端
        async function saveChatMessageToBackend(message, isUser) {
            try {
                const response = await fetch('/api/save_chat_message/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCsrfToken()
                    },
                    body: JSON.stringify({
                        message: message,
                        is_user: isUser
                    })
                }, { passive: true });
                
                const result = await response.json();
                if (result.status === 'success') {
                    console.log('聊天记录保存成功');
                } else {
                    console.error('聊天记录保存失败:', result.message);
                }
            } catch (error) {
                console.error('保存聊天记录时出错:', error);
            }
        }
        
        // 加载历史聊天记录
        async function loadChatHistory() {
            try {
                const response = await fetch('/api/get_chat_history/?limit=50');
                const result = await response.json();
                
                if (result.status === 'success') {
                    const history = result.chat_history;
                    // 清空当前对话区域（保留欢迎消息）
                    const messages = conversationDiv.querySelectorAll('.message:not(.welcome-message)');
                    messages.forEach(msg => msg.remove());
                    
                    // 按时间顺序显示历史记录
                    history.reverse().forEach(chat => {
                        addMessageToUI(chat.message, chat.is_user, false); // false表示不保存到后端
                    });
                } else {
                    console.error('加载聊天历史失败:', result.message);
                }
            } catch (error) {
                console.error('加载聊天历史时出错:', error);
            }
        }
        
        // 清空聊天记录
        async function clearChatHistory() {
            try {
                // 显示确认对话框
                if (!confirm('确定要清空所有聊天记录吗？此操作不可恢复。')) {
                    return;
                }
                
                const response = await fetch('/api/clear_chat_history/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCsrfToken()
                    }
                });
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    // 清空当前对话区域（保留欢迎消息）
                    const messages = conversationDiv.querySelectorAll('.message:not(.welcome-message)');
                    messages.forEach(msg => msg.remove());
                    
                    console.log('聊天记录清空成功:', result.message);
                } else {
                    console.error('清空聊天记录失败:', result.message);
                    alert('清空聊天记录失败: ' + result.message);
                }
            } catch (error) {
                console.error('清空聊天记录时出错:', error);
                alert('清空聊天记录时出错: ' + error.message);
            }
        }
        
        // 获取CSRF令牌
        function getCsrfToken() {
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                const [name, value] = cookie.trim().split('=');
                if (name === 'csrftoken') {
                    return value;
                }
            }
            return '';
        }
        
        // 添加消息到会话记录
        function addMessage(text, isUser = false) {
            // 不移除欢迎消息，保持欢迎语显示状态
            // const welcomeMessage = conversationDiv.querySelector('.welcome-message');
            // if (welcomeMessage) {
            //     welcomeMessage.remove();
            // }
            
            // 添加消息到UI
            addMessageToUI(text, isUser, true);
            
            // 保存聊天记录到后端
            saveChatMessageToBackend(text, isUser);
        }
        
        // 添加消息到UI（不保存到后端）
        function addMessageToUI(text, isUser = false, saveToBackend = true) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'ai'}`;
            
            // 创建消息内容容器
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            
            // 使用marked.js解析Markdown内容
            try {
                messageContent.innerHTML = marked.parse(text);
            } catch (error) {
                console.error('Markdown解析错误:', error);
                // 如果解析失败，回退到纯文本显示
                messageContent.textContent = text;
            }
            
            messageDiv.appendChild(messageContent);
            
            // 添加时间戳
            const timeDiv = document.createElement('div');
            timeDiv.className = 'message-time';
            timeDiv.textContent = new Date().toLocaleTimeString();
            messageDiv.appendChild(timeDiv);
            
            conversationDiv.appendChild(messageDiv);
            conversationDiv.scrollTop = conversationDiv.scrollHeight;
        }


        // 检查当前输入模式
        function getCurrentInputMode() {
            const activeTab = document.querySelector('.input-tab.active');
            return activeTab ? activeTab.getAttribute('data-tab') : 'voice';
        }

        // 开始音频缓冲过程
        function startAudioBuffering() {
            if (isAudioBuffering || isAudioPlaying) return;
            
            // 检查输入模式：文本输入模式下不自动播放音频
            const currentMode = getCurrentInputMode();
            if (currentMode === 'text') {
                log('文本输入模式，不自动播放音频', 'info');
                return;
            }

            isAudioBuffering = true;
            log("开始音频缓冲...", 'info');

            // 先尝试初始化解码器，以便在播放时已准备好
            initOpusDecoder().catch(error => {
                log(`预初始化Opus解码器失败: ${error.message}`, 'warning');
                // 继续缓冲，我们会在播放时再次尝试初始化
            });

            // 设置超时，如果在一定时间内没有收集到足够的音频包，就开始播放
            setTimeout(() => {
                if (isAudioBuffering && audioBufferQueue.length > 0) {
                    log(`缓冲超时，当前缓冲包数: ${audioBufferQueue.length}，开始播放`, 'info');
                    playBufferedAudio();
                }
            }, 300); // 300ms超时

            // 监控缓冲进度
            const bufferCheckInterval = setInterval(() => {
                if (!isAudioBuffering) {
                    clearInterval(bufferCheckInterval);
                    return;
                }

                // 当累积了足够的音频包，开始播放
                if (audioBufferQueue.length >= BUFFER_THRESHOLD) {
                    clearInterval(bufferCheckInterval);
                    log(`已缓冲 ${audioBufferQueue.length} 个音频包，开始播放`, 'info');
                    playBufferedAudio();
                }
            }, 50);
        }

        // 播放已缓冲的音频
        function playBufferedAudio() {
            if (isAudioPlaying || audioBufferQueue.length === 0) return;

            isAudioPlaying = true;
            isAudioBuffering = false;

            // 确保Opus解码器已初始化
            const initDecoderAndPlay = async () => {
                try {
                    // 确保音频上下文存在
                    if (!audioContext) {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)({
                            sampleRate: SAMPLE_RATE
                        });
                        log('创建音频上下文，采样率: ' + SAMPLE_RATE + 'Hz', 'debug');
                    }

                    // 确保解码器已初始化
                    if (!opusDecoder) {
                        log('初始化Opus解码器...', 'info');
                        try {
                            opusDecoder = await initOpusDecoder();
                            if (!opusDecoder) {
                                throw new Error('解码器初始化失败');
                            }
                            log('Opus解码器初始化成功', 'success');
                        } catch (error) {
                            log('Opus解码器初始化失败: ' + error.message, 'error');
                            isAudioPlaying = false;
                            return;
                        }
                    }

                    // 创建流式播放上下文
                    if (!streamingContext) {
                        streamingContext = {
                            queue: [],          // 已解码的PCM队列
                            playing: false,     // 是否正在播放
                            endOfStream: false, // 是否收到结束信号
                            source: null,       // 当前音频源
                            totalSamples: 0,    // 累积的总样本数
                            lastPlayTime: 0,    // 上次播放的时间戳

                            // 将Opus数据解码为PCM
                            decodeOpusFrames: async function (opusFrames) {
                                if (!opusDecoder) {
                                    log('Opus解码器未初始化，无法解码', 'error');
                                    return;
                                }

                                let decodedSamples = [];

                                for (const frame of opusFrames) {
                                    try {
                                        // 使用Opus解码器解码
                                        const frameData = opusDecoder.decode(frame);
                                        if (frameData && frameData.length > 0) {
                                            // 转换为Float32
                                            const floatData = convertInt16ToFloat32(frameData);
                                            // 使用循环替代展开运算符
                                            for (let i = 0; i < floatData.length; i++) {
                                                decodedSamples.push(floatData[i]);
                                            }
                                        }
                                    } catch (error) {
                                        log("Opus解码失败: " + error.message, 'error');
                                    }
                                }

                                if (decodedSamples.length > 0) {
                                    // 使用循环替代展开运算符
                                    for (let i = 0; i < decodedSamples.length; i++) {
                                        this.queue.push(decodedSamples[i]);
                                    }
                                    this.totalSamples += decodedSamples.length;

                                    // 如果累积了至少0.2秒的音频，开始播放
                                    const minSamples = SAMPLE_RATE * MIN_AUDIO_DURATION;
                                    if (!this.playing && this.queue.length >= minSamples) {
                                        this.startPlaying();
                                    }
                                } else {
                                    log('没有成功解码的样本', 'warning');
                                }
                            },

                            // 开始播放音频
                            startPlaying: function () {
                                if (this.playing || this.queue.length === 0) return;

                                this.playing = true;

                                // 创建新的音频缓冲区
                                const minPlaySamples = Math.min(this.queue.length, SAMPLE_RATE); // 最多播放1秒
                                const currentSamples = this.queue.splice(0, minPlaySamples);

                                const audioBuffer = audioContext.createBuffer(CHANNELS, currentSamples.length, SAMPLE_RATE);
                                audioBuffer.copyToChannel(new Float32Array(currentSamples), 0);

                                // 创建音频源
                                this.source = audioContext.createBufferSource();
                                this.source.buffer = audioBuffer;

                                // 创建增益节点用于平滑过渡
                                const gainNode = audioContext.createGain();

                                // 应用淡入淡出效果避免爆音
                                const fadeDuration = 0.02; // 20毫秒
                                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                                gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + fadeDuration);

                                const duration = audioBuffer.duration;
                                if (duration > fadeDuration * 2) {
                                    gainNode.gain.setValueAtTime(1, audioContext.currentTime + duration - fadeDuration);
                                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
                                }

                                // 连接节点并开始播放
                                this.source.connect(gainNode);
                                gainNode.connect(audioContext.destination);

                                this.lastPlayTime = audioContext.currentTime;
                                log(`开始播放 ${currentSamples.length} 个样本，约 ${(currentSamples.length / SAMPLE_RATE).toFixed(2)} 秒`, 'info');

                                // 播放结束后的处理
                                this.source.onended = () => {
                                    this.source = null;
                                    this.playing = false;

                                    // 使用setTimeout避免递归调用
                                    setTimeout(() => {
                                        // 如果队列中还有数据，继续播放
                                        if (this.queue.length > 0) {
                                            this.startPlaying();
                                        } else if (audioBufferQueue.length > 0) {
                                            // 缓冲区有新数据，进行解码
                                            const frames = [...audioBufferQueue];
                                            audioBufferQueue = [];
                                            this.decodeOpusFrames(frames);
                                        } else if (this.endOfStream) {
                                            // 流已结束且没有更多数据
                                            log("音频播放完成", 'info');
                                            isAudioPlaying = false;
                                            this.endOfStream = false;
                                            streamingContext = null;
                                        } else {
                                            // 等待更多数据
                                            setTimeout(() => {
                                                // 如果仍然没有新数据，但有更多的包到达
                                                if (this.queue.length === 0 && audioBufferQueue.length > 0) {
                                                    const frames = [...audioBufferQueue];
                                                    audioBufferQueue = [];
                                                    this.decodeOpusFrames(frames);
                                                } else if (this.queue.length === 0 && audioBufferQueue.length === 0) {
                                                    // 真的没有更多数据了
                                                    log("音频播放完成 (超时)", 'info');
                                                    isAudioPlaying = false;
                                                    streamingContext = null;
                                                }
                                            }, 500); // 500ms超时
                                        }
                                    }, 10); // 10ms延迟，避免立即递归
                                };

                                this.source.start();
                            }
                        };
                    }

                    // 开始处理缓冲的数据
                    const frames = [...audioBufferQueue];
                    audioBufferQueue = []; // 清空缓冲队列

                    // 解码并播放
                    await streamingContext.decodeOpusFrames(frames);

                } catch (error) {
                    log(`播放已缓冲的音频出错: ${error.message}`, 'error');
                    isAudioPlaying = false;
                    streamingContext = null;
                }
            };

            // 执行初始化和播放
            initDecoderAndPlay();
        }

        // 将Int16音频数据转换为Float32音频数据
        function convertInt16ToFloat32(int16Data) {
            const float32Data = new Float32Array(int16Data.length);
            for (let i = 0; i < int16Data.length; i++) {
                // 将[-32768,32767]范围转换为[-1,1]
                float32Data[i] = int16Data[i] / (int16Data[i] < 0 ? 0x8000 : 0x7FFF);
            }
            return float32Data;
        }

        // 初始化Opus解码器 - 确保完全初始化完成后才返回
        async function initOpusDecoder() {
            if (opusDecoder) return opusDecoder; // 已经初始化

            try {
                // 检查ModuleInstance是否存在
                if (typeof window.ModuleInstance === 'undefined') {
                    if (typeof Module !== 'undefined') {
                        // 使用全局Module作为ModuleInstance
                        window.ModuleInstance = Module;
                        log('使用全局Module作为ModuleInstance', 'info');
                    } else {
                        throw new Error('Opus库未加载，ModuleInstance和Module对象都不存在');
                    }
                }

                const mod = window.ModuleInstance;

                // 创建解码器对象
                opusDecoder = {
                    channels: CHANNELS,
                    rate: SAMPLE_RATE,
                    frameSize: FRAME_SIZE,
                    module: mod,
                    decoderPtr: null, // 初始为null

                    // 初始化解码器
                    init: function () {
                        if (this.decoderPtr) return true; // 已经初始化

                        // 获取解码器大小
                        const decoderSize = mod._opus_decoder_get_size(this.channels);
                        log(`Opus解码器大小: ${decoderSize}字节`, 'debug');

                        // 分配内存
                        this.decoderPtr = mod._malloc(decoderSize);
                        if (!this.decoderPtr) {
                            throw new Error("无法分配解码器内存");
                        }

                        // 初始化解码器
                        const err = mod._opus_decoder_init(
                            this.decoderPtr,
                            this.rate,
                            this.channels
                        );

                        if (err < 0) {
                            this.destroy(); // 清理资源
                            throw new Error(`Opus解码器初始化失败: ${err}`);
                        }

                        log("Opus解码器初始化成功", 'success');
                        return true;
                    },

                    // 解码方法
                    decode: function (opusData) {
                        if (!this.decoderPtr) {
                            if (!this.init()) {
                                throw new Error("解码器未初始化且无法初始化");
                            }
                        }

                        try {
                            const mod = this.module;

                            // 为Opus数据分配内存
                            const opusPtr = mod._malloc(opusData.length);
                            mod.HEAPU8.set(opusData, opusPtr);

                            // 为PCM输出分配内存
                            const pcmPtr = mod._malloc(this.frameSize * 2); // Int16 = 2字节

                            // 解码
                            const decodedSamples = mod._opus_decode(
                                this.decoderPtr,
                                opusPtr,
                                opusData.length,
                                pcmPtr,
                                this.frameSize,
                                0 // 不使用FEC
                            );

                            if (decodedSamples < 0) {
                                mod._free(opusPtr);
                                mod._free(pcmPtr);
                                throw new Error(`Opus解码失败: ${decodedSamples}`);
                            }

                            // 复制解码后的数据
                            const decodedData = new Int16Array(decodedSamples);
                            for (let i = 0; i < decodedSamples; i++) {
                                decodedData[i] = mod.HEAP16[(pcmPtr >> 1) + i];
                            }

                            // 释放内存
                            mod._free(opusPtr);
                            mod._free(pcmPtr);

                            return decodedData;
                        } catch (error) {
                            log(`Opus解码错误: ${error.message}`, 'error');
                            return new Int16Array(0);
                        }
                    },

                    // 销毁方法
                    destroy: function () {
                        if (this.decoderPtr) {
                            this.module._free(this.decoderPtr);
                            this.decoderPtr = null;
                        }
                    }
                };

                // 初始化解码器
                if (!opusDecoder.init()) {
                    throw new Error("Opus解码器初始化失败");
                }

                return opusDecoder;

            } catch (error) {
                log(`Opus解码器初始化失败: ${error.message}`, 'error');
                opusDecoder = null; // 重置为null，以便下次重试
                throw error;
            }
        }

        // 初始化音频录制和处理
        async function initAudio() {
            try {
                // 请求麦克风权限
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 16000,  // 确保16kHz采样率
                        channelCount: 1     // 确保单声道
                    }
                });
                log('已获取麦克风访问权限', 'success');

                // 创建音频上下文
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000,  // 确保采样率与服务器期望的一致
                    latencyHint: 'interactive'
                });
                const source = audioContext.createMediaStreamSource(stream);

                // 获取实际音频轨道设置
                const audioTracks = stream.getAudioTracks();
                if (audioTracks.length > 0) {
                    const track = audioTracks[0];
                    const settings = track.getSettings();
                    log(`实际麦克风设置 - 采样率: ${settings.sampleRate || '未知'}Hz, 声道数: ${settings.channelCount || '未知'}`, 'info');
                }

                // 创建分析器用于可视化
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);

                // 尝试初始化MediaRecorder，按优先级尝试不同编码选项
                try {
                    // 优先尝试使用Opus编码
                    mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'audio/webm;codecs=opus',
                        audioBitsPerSecond: 16000
                    });
                    log('已初始化MediaRecorder (使用Opus编码)', 'success');
                    log(`选择的编码格式: ${mediaRecorder.mimeType}`, 'info');
                } catch (e1) {
                    try {
                        // 如果Opus不支持，尝试MP3
                        mediaRecorder = new MediaRecorder(stream, {
                            mimeType: 'audio/webm',
                            audioBitsPerSecond: 16000
                        });
                        log('已初始化MediaRecorder (使用WebM标准编码，Opus不支持)', 'warning');
                        log(`选择的编码格式: ${mediaRecorder.mimeType}`, 'info');
                    } catch (e2) {
                        try {
                            // 尝试其他备选格式
                            mediaRecorder = new MediaRecorder(stream, {
                                mimeType: 'audio/ogg;codecs=opus',
                                audioBitsPerSecond: 16000
                            });
                            log('已初始化MediaRecorder (使用OGG+Opus编码)', 'warning');
                            log(`选择的编码格式: ${mediaRecorder.mimeType}`, 'info');
                        } catch (e3) {
                            // 最后使用默认编码
                            mediaRecorder = new MediaRecorder(stream);
                            log(`已初始化MediaRecorder (使用默认编码: ${mediaRecorder.mimeType})`, 'warning');
                        }
                    }
                }

                // 处理录制的数据
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                // 录制结束后处理数据
                mediaRecorder.onstop = async () => {
                    // 停止可视化
                    if (visualizationRequest) {
                        cancelAnimationFrame(visualizationRequest);
                        visualizationRequest = null;
                    }

                    log(`录音结束，已收集的音频块数量: ${audioChunks.length}`, 'info');
                    if (audioChunks.length === 0) {
                        log('警告：没有收集到任何音频数据，请检查麦克风是否工作正常', 'error');
                        return;
                    }

                    // 创建完整的录音blob
                    const blob = new Blob(audioChunks, { type: audioChunks[0].type });
                    log(`已创建音频Blob，MIME类型: ${audioChunks[0].type}，大小: ${(blob.size / 1024).toFixed(2)} KB`, 'info');

                    // 保存原始块，以防清空后需要调试
                    const chunks = [...audioChunks];
                    audioChunks = [];

                    try {
                        // 将blob转换为ArrayBuffer
                        const arrayBuffer = await blob.arrayBuffer();
                        const uint8Array = new Uint8Array(arrayBuffer);

                        log(`已转换为Uint8Array，准备发送，大小: ${(arrayBuffer.byteLength / 1024).toFixed(2)} KB`, 'info');

                        // 检查WebSocket状态
                        if (!websocket) {
                            log('错误：WebSocket连接不存在', 'error');
                            return;
                        }

                        if (websocket.readyState !== WebSocket.OPEN) {
                            log(`错误：WebSocket连接未打开，当前状态: ${websocket.readyState}`, 'error');
                            return;
                        }

                        // 直接发送二进制音频数据 - 这是最简单有效的方式
                        try {
                            // 注意：开始和结束消息已在录音开始和结束时发送
                            // 这里只需要发送音频数据
                            await new Promise(resolve => setTimeout(resolve, 50));

                            // 处理WebM容器格式，提取纯Opus数据
                            // 服务器使用opuslib_next.Decoder，需要纯Opus帧
                            log('正在处理音频数据，提取纯Opus帧...', 'info');
                            const opusData = extractOpusFrames(uint8Array);

                            // 记录Opus数据大小
                            log(`已提取Opus数据，大小: ${(opusData.byteLength / 1024).toFixed(2)} KB`, 'info');

                            // 发送音频消息第二步：二进制音频数据
                            websocket.send(opusData);
                            log(`已发送Opus音频数据: ${(opusData.byteLength / 1024).toFixed(2)} KB`, 'success');
                        } catch (error) {
                            log(`音频数据发送失败: ${error.message}`, 'error');

                            // 尝试使用base64编码作为备选方案
                            try {
                                log('尝试使用base64编码方式发送...', 'info');
                                const base64Data = arrayBufferToBase64(arrayBuffer);
                                const audioDataMessage = {
                                    type: 'audio',
                                    action: 'data',
                                    format: 'opus',
                                    sample_rate: 16000,
                                    channels: 1,
                                    mime_type: chunks[0].type,
                                    encoding: 'base64',
                                    data: base64Data
                                };
                                websocket.send(JSON.stringify(audioDataMessage));
                                log(`已使用base64编码发送音频数据: ${(arrayBuffer.byteLength / 1024).toFixed(2)} KB`, 'warning');
                            } catch (base64Error) {
                                log(`所有数据发送方式均失败: ${base64Error.message}`, 'error');
                            }
                        }
                    } catch (error) {
                        log(`处理录音数据错误: ${error.message}`, 'error');
                    }
                };

                // 尝试初始化Opus解码器
                try {
                    // 检查ModuleInstance是否存在（本地库导出的全局变量）
                    if (typeof window.ModuleInstance === 'undefined') {
                        throw new Error('Opus库未加载，ModuleInstance对象不存在');
                    }

                    // 简单测试ModuleInstance是否可用
                    if (typeof window.ModuleInstance._opus_decoder_get_size === 'function') {
                        const testSize = window.ModuleInstance._opus_decoder_get_size(1);
                        log(`Opus解码器测试成功，解码器大小: ${testSize} 字节`, 'success');
                    } else {
                        throw new Error('Opus解码函数未找到');
                    }
                } catch (err) {
                    log(`Opus解码器初始化警告: ${err.message}，将在需要时重试`, 'warning');
                }

                log('音频系统初始化完成', 'success');
                return true;
            } catch (error) {
                log(`音频初始化错误: ${error.message}`, 'error');
                return false;
            }
        }

        // 开始录音
        function startRecording() {
            if (isRecording) return;

            try {
                // 最小录音时长提示
                log('请至少录制1-2秒钟的音频，确保采集到足够数据', 'info');

                // 获取服务器类型 - 从URL判断
                const serverUrl = serverUrlInput.value.trim();
                let isXiaozhiNative = false;

                // 检查是否是小智原生服务器 (根据URL特征判断)
                if (serverUrl.includes('xiaozhi') || serverUrl.includes('localhost') || serverUrl.includes('127.0.0.1')) {
                    isXiaozhiNative = true;
                    log('检测到小智原生服务器，使用标准listen协议', 'info');
                }

                // 使用直接PCM录音和libopus编码的方式
                startDirectRecording();
            } catch (error) {
                log(`录音启动错误: ${error.message}`, 'error');
            }
        }

        // 停止录音
        function stopRecording() {
            if (!isRecording) {
                // 如果状态显示未在录音，但UI显示正在录音，强制重置状态
                if (recordButton.classList.contains('recording')) {
                    log('检测到状态不一致，强制重置录音状态', 'warning');
                    forceResetRecordingState();
                }
                return;
            }

            try {
                // 使用直接PCM录音停止
                const result = stopDirectRecording();
                
                // 确保状态被正确重置
                if (result !== true) {
                    log('停止录音返回失败，强制重置状态', 'warning');
                    forceResetRecordingState();
                }
                
                // 额外确保状态重置
                setTimeout(() => {
                    if (isRecording) {
                        log('检测到录音状态未正确重置，强制重置', 'warning');
                        forceResetRecordingState();
                    }
                }, 100);
            } catch (error) {
                log(`停止录音错误: ${error.message}`, 'error');
                // 出现错误时强制重置状态
                forceResetRecordingState();
            }
        }
        
        // 强制重置录音状态
        function forceResetRecordingState() {
            isRecording = false;
            
            // 清除录音计时器
            if (window.recordingTimer) {
                clearInterval(window.recordingTimer);
                window.recordingTimer = null;
            }
            
            // 停止音频处理器
            if (audioProcessor) {
                try {
                    if (audioProcessorType === 'worklet' && audioProcessor.port) {
                        audioProcessor.port.postMessage({ command: 'stop' });
                    }
                    audioProcessor.disconnect();
                } catch (e) {
                    log('停止音频处理器时出错: ' + e.message, 'error');
                }
                audioProcessor = null;
            }
            
            // 断开音频源
            if (audioSource) {
                try {
                    audioSource.disconnect();
                } catch (e) {
                    log('断开音频源时出错: ' + e.message, 'error');
                }
                audioSource = null;
            }
            
            // 停止可视化
            if (visualizationRequest) {
                cancelAnimationFrame(visualizationRequest);
                visualizationRequest = null;
            }
            
            // 重置UI
            recordButton.innerHTML = '<span style="font-size: 0.75rem;">开始</span>';
            recordButton.classList.remove('recording');
            recordButton.disabled = false;
            
            log('录音状态已强制重置', 'info');
        }

        // 连接WebSocket服务器
        async function connectToServer() {
            const url = serverUrlInput.value.trim();
            if (url === '') return;

            try {
                // 获取并验证配置
                const config = getConfig();
                if (!validateConfig(config)) {
                    return;
                }

                // 检查URL格式
                if (!url.startsWith('ws://') && !url.startsWith('wss://')) {
                    log('URL格式错误，必须以ws://或wss://开头', 'error');
                    return;
                }

                // 先检查OTA状态
                log('正在检查OTA状态...', 'info');
                const otaUrl = document.getElementById('otaUrl').value.trim();
                localStorage.setItem('otaUrl', otaUrl);
                localStorage.setItem('wsUrl', url);
                try {
                    const otaResponse = await fetch(otaUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Device-Id': config.deviceId,
                            'Client-Id': config.clientId
                        },
                        body: JSON.stringify({
                            "version": 0,
                            "uuid": "",
                            "application": {
                                "name": "xiaozhi-web-test",
                                "version": "1.0.0",
                                "compile_time": "2025-04-16 10:00:00",
                                "idf_version": "4.4.3",
                                "elf_sha256": "1234567890abcdef1234567890abcdef1234567890abcdef"
                            },
                            "ota": {
                                "label": "xiaozhi-web-test",
                            },
                            "board": {
                                "type": "xiaozhi-web-test",
                                "ssid": "xiaozhi-web-test",
                                "rssi": 0,
                                "channel": 0,
                                "ip": "192.168.1.1",
                                "mac": config.deviceMac
                            },
                            "flash_size": 0,
                            "minimum_free_heap_size": 0,
                            "mac_address": config.deviceMac,
                            "chip_model_name": "",
                            "chip_info": {
                                "model": 0,
                                "cores": 0,
                                "revision": 0,
                                "features": 0
                            },
                            "partition_table": [
                                {
                                    "label": "",
                                    "type": 0,
                                    "subtype": 0,
                                    "address": 0,
                                    "size": 0
                                }
                            ]
                        })
                    });

                    if (!otaResponse.ok) {
                        throw new Error(`OTA检查失败: ${otaResponse.status} ${otaResponse.statusText}`);
                    }

                    const otaResult = await otaResponse.json();
                    log(`OTA检查结果: ${JSON.stringify(otaResult)}`, 'info');

                    log('OTA检查通过，开始连接WebSocket...', 'success');
                    if (otaStatus) {
                    otaStatus.textContent = 'ota已连接';
                    otaStatus.style.color = 'green';
                }
                } catch (error) {
                    log(`OTA检查错误: ${error.message}`, 'error');
                    if (otaStatus) {
                        otaStatus.textContent = 'ota未连接';
                        otaStatus.style.color = 'red';
                    }
                }

                // 使用自定义WebSocket实现以添加认证头信息
                let connUrl = new URL(url);

                // 添加认证参数
                connUrl.searchParams.append('device-id', config.deviceId);
                connUrl.searchParams.append('client-id', config.clientId);

                log(`正在连接: ${connUrl.toString()}`, 'info');
                websocket = new WebSocket(connUrl.toString());

                // 设置接收二进制数据的类型为ArrayBuffer
                websocket.binaryType = 'arraybuffer';

                websocket.onopen = async () => {
                    log(`已连接到服务器: ${url}`, 'success');
                    if (connectionStatus) {
                    connectionStatus.textContent = 'ws已连接';
                    connectionStatus.style.color = 'green';
                }

                    // 连接成功后发送hello消息
                    await sendHelloMessage();

                    connectButton.textContent = '断开';
                    connectButton.removeEventListener('click', connectToServer);
                    connectButton.addEventListener('click', disconnectFromServer);
                    // connectButton.onclick = disconnectFromServer;
                    messageInput.disabled = false;
                    sendTextButton.disabled = false;

                    const audioInitialized = await initAudio();
                    if (audioInitialized) {
                        recordButton.disabled = false;
                    }
                };

                websocket.onclose = () => {
                    log('已断开连接', 'info');
                    if (connectionStatus) {
                    connectionStatus.textContent = 'ws已断开';
                    connectionStatus.style.color = 'red';
                }

                    connectButton.textContent = '连接';
                    connectButton.removeEventListener('click', disconnectFromServer);
                    connectButton.addEventListener('click', connectToServer);
                    // connectButton.onclick = connectToServer;
                    messageInput.disabled = true;
                    sendTextButton.disabled = true;
                    recordButton.disabled = true;
                    stopButton.disabled = true;
                };

                websocket.onerror = (error) => {
                    log(`WebSocket错误: ${error.message || '未知错误'}`, 'error');
                    if (connectionStatus) {
                          connectionStatus.textContent = 'ws未连接';
                          connectionStatus.style.color = 'red';
                      }
                };

                websocket.onmessage = function (event) {
                    try {
                        // 检查是否为文本消息
                        if (typeof event.data === 'string') {
                            const message = JSON.parse(event.data);

                            if (message.type === 'hello') {
                                log(`服务器回应：${JSON.stringify(message, null, 2)}`, 'success');
                            } else if (message.type === 'tts') {
                                // TTS状态消息
                                if (message.state === 'start') {
                                    log('服务器开始发送语音', 'info');
                                } else if (message.state === 'sentence_start') {
                                    log(`服务器发送语音段: ${message.text}`, 'info');
                                    // 添加文本到会话记录
                                    if (message.text) {
                                        addMessage(message.text);
                                    }
                                } else if (message.state === 'sentence_end') {
                                    log(`语音段结束: ${message.text}`, 'info');
                                } else if (message.state === 'stop') {
                                    log('服务器语音传输结束', 'info');
                                    // 结束后更新UI状态
                                    if (recordButton.disabled) {
                                        recordButton.disabled = false;
                                        recordButton.textContent = '开始录音';
                                        recordButton.classList.remove('recording');
                                    }
                                }
                            } else if (message.type === 'audio') {
                                // 音频控制消息
                                log(`收到音频控制消息: ${JSON.stringify(message)}`, 'info');
                            } else if (message.type === 'stt') {
                                // 语音识别结果
                                log(`识别结果: ${message.text}`, 'info');
                                // 添加识别结果到会话记录，但不显示普通消息
                                addMessage(` ${message.text}`, true);
                            } else if (message.type === 'llm') {
                                // 大模型回复
                                log(`大模型回复: ${message.text}`, 'info');
                                // 添加大模型回复到会话记录，过滤掉emoji表情
                                if (message.text) {
                                    // 移除所有emoji表情符号
                                    const cleanText = message.text.replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '').trim();
                                    if (cleanText) {
                                        addMessage(cleanText);
                                    }
                                }
                            }else if (message.type === 'mcp') {
                                const payload = message.payload || {};
                                log(`服务器下发: ${JSON.stringify(message)}`, 'info');
                                if (payload) {
                                    // 模拟小智客户端行为
                                    if(payload.method === 'tools/list'){
                                        const replay_message = JSON.stringify({"session_id":"","type":"mcp","payload":{"jsonrpc":"2.0","id":2,"result":{"tools":[{"name":"self.get_device_status","description":"Provides the real-time information of the device, including the current status of the audio speaker, screen, battery, network, etc.\nUse this tool for: \n1. Answering questions about current condition (e.g. what is the current volume of the audio speaker?)\n2. As the first step to control the device (e.g. turn up / down the volume of the audio speaker, etc.)","inputSchema":{"type":"object","properties":{}}},{"name":"self.audio_speaker.set_volume","description":"Set the volume of the audio speaker. If the current volume is unknown, you must call `self.get_device_status` tool first and then call this tool.","inputSchema":{"type":"object","properties":{"volume":{"type":"integer","minimum":0,"maximum":100}},"required":["volume"]}},{"name":"self.screen.set_brightness","description":"Set the brightness of the screen.","inputSchema":{"type":"object","properties":{"brightness":{"type":"integer","minimum":0,"maximum":100}},"required":["brightness"]}},{"name":"self.screen.set_theme","description":"Set the theme of the screen. The theme can be 'light' or 'dark'.","inputSchema":{"type":"object","properties":{"theme":{"type":"string"}},"required":["theme"]}}]}}})
                                        websocket.send(replay_message);
                                        log(`回复MCP消息: ${replay_message}`, 'info');
                                    } else if(payload.method === 'tools/call'){
                                        // 模拟回复
                                        const replay_message = JSON.stringify({"session_id":"9f261599","type":"mcp","payload":{"jsonrpc":"2.0","id": payload.id,"result":{"content":[{"type":"text","text":"true"}],"isError":false}}})
                                        websocket.send(replay_message);
                                        log(`回复MCP消息: ${replay_message}`, 'info');
                                    }
                                }
                                
                            } else {
                                // 未知消息类型
                                log(`未知消息类型: ${message.type}`, 'info');
                                addMessage(JSON.stringify(message, null, 2));
                            }
                        } else {
                            // 处理二进制数据 - 兼容多种二进制格式
                            handleBinaryMessage(event.data);
                        }
                    } catch (error) {
                        log(`WebSocket消息处理错误: ${error.message}`, 'error');
                        // 非JSON格式文本消息直接显示
                        if (typeof event.data === 'string') {
                            addMessage(event.data);
                        }
                    }
                };

                if (connectionStatus) {
                connectionStatus.textContent = 'ws未连接';
                connectionStatus.style.color = 'orange';
            }
            } catch (error) {
                log(`连接错误: ${error.message}`, 'error');
                connectionStatus.textContent = 'ws未连接';
            }
        }

        // 发送hello握手消息
        async function sendHelloMessage() {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) return;

            try {
                const config = getConfig();

                // 设置设备信息
                const helloMessage = {
                    type: 'hello',
                    device_id: config.deviceId,
                    device_name: config.deviceName,
                    device_mac: config.deviceMac,
                    token: config.token,
                    features: {
                        mcp: true
                    }
                };

                log('发送hello握手消息', 'info');
                websocket.send(JSON.stringify(helloMessage));

                // 等待服务器响应
                return new Promise(resolve => {
                    // 5秒超时
                    const timeout = setTimeout(() => {
                        log('等待hello响应超时', 'error');
                        log('提示: 请尝试点击"测试认证"按钮进行连接排查', 'info');
                        resolve(false);
                    }, 5000);

                    // 临时监听一次消息，接收hello响应
                    const onMessageHandler = (event) => {
                        try {
                            const response = JSON.parse(event.data);
                            if (response.type === 'hello' && response.session_id) {
                                log(`服务器握手成功，会话ID: ${response.session_id}`, 'success');
                                clearTimeout(timeout);
                                websocket.removeEventListener('message', onMessageHandler);
                                resolve(true);
                            }
                        } catch (e) {
                            // 忽略非JSON消息
                        }
                    };

                    websocket.addEventListener('message', onMessageHandler);
                });
            } catch (error) {
                log(`发送hello消息错误: ${error.message}`, 'error');
                return false;
            }
        }

        // 断开WebSocket连接
        function disconnectFromServer() {
            if (!websocket) return;

            websocket.close();
            stopRecording();
        }

        // 发送文本消息
        function sendTextMessage() {
            const message = messageInput.value.trim();
            if (message === '' || !websocket || websocket.readyState !== WebSocket.OPEN) return;

            audioBufferQueue = [];
            isAudioBuffering = false;
            isAudioPlaying = false;

            try {
                // 直接发送listen消息，不需要重复发送hello
                const listenMessage = {
                    type: 'listen',
                    mode: 'manual',
                    state: 'detect',
                    text: message
                };

                websocket.send(JSON.stringify(listenMessage));
                // 不显示普通消息，只显示带有[语音识别]标识的消息
                log(`发送文本消息: ${message}`, 'info');

                messageInput.value = '';
            } catch (error) {
                log(`发送消息错误: ${error.message}`, 'error');
            }
        }

        // 发送快捷消息
        function sendQuickMessage(message) {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                log('请先连接到服务器', 'error');
                return;
            }

            audioBufferQueue = [];
            isAudioBuffering = false;
            isAudioPlaying = false;

            try {
                // 直接发送listen消息
                const listenMessage = {
                    type: 'listen',
                    mode: 'manual',
                    state: 'detect',
                    text: message
                };

                websocket.send(JSON.stringify(listenMessage));
                log(`发送快捷消息: ${message}`, 'info');
            } catch (error) {
                log(`发送快捷消息错误: ${error.message}`, 'error');
            }
        }

        // 生成随机MAC地址
        function generateRandomMac() {
            const hexDigits = '0123456789ABCDEF';
            let mac = '';
            for (let i = 0; i < 6; i++) {
                if (i > 0) mac += ':';
                for (let j = 0; j < 2; j++) {
                    mac += hexDigits.charAt(Math.floor(Math.random() * 16));
                }
            }
            return mac;
        }

        // 初始化事件监听器
        // 初始化事件监听器
        function initEventListeners() {
            connectButton.addEventListener('click', connectToServer);
            document.getElementById('authTestButton').addEventListener('click', testAuthentication);

            // 从localStorage加载MAC地址，如果没有则生成新的
            const deviceMacInput = document.getElementById('deviceMac');
            let savedMac = localStorage.getItem('deviceMac');
            if (!savedMac) {
                savedMac = generateRandomMac();
                localStorage.setItem('deviceMac', savedMac);
            }
            deviceMacInput.value = savedMac;

            const savedOtaUrl = localStorage.getItem('otaUrl');
            if (savedOtaUrl) {
                document.getElementById('otaUrl').value = savedOtaUrl;
            }

            const savedWsUrl = localStorage.getItem('wsUrl');
            if (savedWsUrl) {
                document.getElementById('serverUrl').value = savedWsUrl;
            }

            // 设置面板切换
            const settingsBtn = document.getElementById('settingsBtn');
            const settingsPanel = document.getElementById('settingsPanel');
            if (settingsBtn && settingsPanel) {
                settingsBtn.addEventListener('click', () => {
                    settingsPanel.classList.toggle('open');
                });
            }

            // 输入标签页切换
            const inputTabs = document.querySelectorAll('.input-tab');
            inputTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // 移除所有标签页的active类
                    inputTabs.forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.input-content').forEach(c => c.classList.remove('active'));

                    // 添加当前标签页的active类
                    tab.classList.add('active');
                    const tabName = tab.getAttribute('data-tab');
                    document.getElementById(`${tabName}InputContent`).classList.add('active');
                    
                    // 更新输入提示文本
                    const inputHint = document.getElementById('inputHint');
                    if (inputHint) {
                        if (tabName === 'text') {
                            inputHint.textContent = '点击文本框输入';
                        } else if (tabName === 'voice') {
                            inputHint.textContent = '点击麦克风开始对话';
                        }
                    }
                    
                    // 如果切换到文本输入模式，清空音频缓冲队列，防止历史语音被播放
                    if (tabName === 'text') {
                        if (audioBufferQueue.length > 0) {
                            log('切换到文本输入模式，清空音频缓冲队列', 'info');
                            audioBufferQueue = [];
                        }
                        // 停止正在播放的音频
                        if (isAudioPlaying || isAudioBuffering) {
                            log('切换到文本输入模式，停止音频播放', 'info');
                            isAudioPlaying = false;
                            isAudioBuffering = false;
                            if (streamingContext && streamingContext.source) {
                                streamingContext.source.stop();
                                streamingContext.source = null;
                            }
                            streamingContext = null;
                        }
                    }
                });
            });

            sendTextButton.addEventListener('click', sendTextMessage);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendTextMessage();
                }
            });

            // 添加防抖处理
            let recordClickDebounce = false;
            
            recordButton.addEventListener('click', () => {
                // 防抖处理，防止快速多次点击
                if (recordClickDebounce) {
                    log('点击过于频繁，请稍候', 'warning');
                    return;
                }
                
                recordClickDebounce = true;
                
                try {
                    if (isRecording) {
                        log('停止录音...', 'info');
                        stopRecording();
                    } else {
                        log('开始录音...', 'info');
                        startRecording();
                    }
                } catch (error) {
                    log(`录音按钮点击错误: ${error.message}`, 'error');
                    // 出现错误时强制重置状态
                    if (typeof forceResetRecordingState === 'function') {
                        forceResetRecordingState();
                    }
                } finally {
                    // 300ms后重置防抖状态
                    setTimeout(() => {
                        recordClickDebounce = false;
                    }, 300);
                }
            });

            window.addEventListener('resize', initVisualizer, { passive: true });
        }

        // 测试认证
        async function testAuthentication() {
            log('开始测试认证...', 'info');

            const config = getConfig();

            // 显示服务器配置
            log('-------- 服务器认证配置检查 --------', 'info');
            log('请确认config.yaml中的auth配置：', 'info');
            log('1. server.auth.enabled 为 false 或服务器已正确配置认证', 'info');
            log('2. 如果启用了认证，请确认使用了正确的token', 'info');
            log(`3. 或者在allowed_devices中添加了测试设备MAC：${config.deviceMac}`, 'info');

            const serverUrl = serverUrlInput.value.trim();
            if (!serverUrl) {
                log('请输入服务器地址', 'error');
                return;
            }

            // 测试连接
            log('尝试不同认证参数的连接：', 'info');

            // 测试1: 无参数连接
            try {
                log('测试1: 尝试无参数连接...', 'info');
                const ws1 = new WebSocket(serverUrl);

                ws1.onopen = () => {
                    log('测试1成功: 无参数可连接，服务器可能没有启用认证', 'success');
                    ws1.close();
                };

                ws1.onerror = (error) => {
                    log('测试1失败: 无参数连接被拒绝，服务器可能启用了认证', 'error');
                };

                // 5秒后关闭测试连接
                setTimeout(() => {
                    if (ws1.readyState === WebSocket.CONNECTING || ws1.readyState === WebSocket.OPEN) {
                        ws1.close();
                    }
                }, 5000);
            } catch (error) {
                log(`测试1出错: ${error.message}`, 'error');
            }

            // 测试2: 带参数连接
            setTimeout(async () => {
                try {
                    log('测试2: 尝试带token参数连接...', 'info');

                    let url = new URL(serverUrl);
                    url.searchParams.append('token', config.token);
                    url.searchParams.append('device_id', config.deviceId);
                    url.searchParams.append('device_mac', config.deviceMac);

                    const ws2 = new WebSocket(url.toString());

                    ws2.onopen = () => {
                        log('测试2成功: 带token参数可连接', 'success');

                        // 尝试发送hello消息
                        const helloMsg = {
                            type: 'hello',
                            device_id: config.deviceId,
                            device_mac: config.deviceMac,
                            token: config.token
                        };

                        ws2.send(JSON.stringify(helloMsg));
                        log('已发送hello测试消息', 'info');

                        // 监听响应
                        ws2.onmessage = (event) => {
                            try {
                                const response = JSON.parse(event.data);
                                if (response.type === 'hello' && response.session_id) {
                                    log(`测试完全成功! 收到hello响应，会话ID: ${response.session_id}`, 'success');
                                    ws2.close();
                                }
                            } catch (e) {
                                log(`收到非JSON响应: ${event.data}`, 'info');
                            }
                        };

                        // 5秒后关闭
                        setTimeout(() => ws2.close(), 5000);
                    };

                    ws2.onerror = (error) => {
                        log('测试2失败: 带token参数连接被拒绝', 'error');
                        log('请检查token是否正确，或服务器是否接受URL参数认证', 'error');
                    };
                } catch (error) {
                    log(`测试2出错: ${error.message}`, 'error');
                }
            }, 6000);

            log('认证测试已启动，请查看测试结果...', 'info');
        }

        // 帮助函数：ArrayBuffer转Base64
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        // 使用libopus创建一个Opus编码器
        let opusEncoder = null;
        function initOpusEncoder() {
            try {
                if (opusEncoder) {
                    return true; // 已经初始化过
                }

                if (!window.ModuleInstance) {
                    log('无法创建Opus编码器：ModuleInstance不可用', 'error');
                    return false;
                }

                // 初始化一个Opus编码器
                const mod = window.ModuleInstance;
                const sampleRate = 16000; // 16kHz采样率
                const channels = 1;       // 单声道
                const application = 2048; // OPUS_APPLICATION_VOIP = 2048

                // 创建编码器
                opusEncoder = {
                    channels: channels,
                    sampleRate: sampleRate,
                    frameSize: 960, // 60ms @ 16kHz = 60 * 16 = 960 samples
                    maxPacketSize: 4000, // 最大包大小
                    module: mod,

                    // 初始化编码器
                    init: function () {
                        try {
                            // 获取编码器大小
                            const encoderSize = mod._opus_encoder_get_size(this.channels);
                            log(`Opus编码器大小: ${encoderSize}字节`, 'info');

                            // 分配内存
                            this.encoderPtr = mod._malloc(encoderSize);
                            if (!this.encoderPtr) {
                                throw new Error("无法分配编码器内存");
                            }

                            // 初始化编码器
                            const err = mod._opus_encoder_init(
                                this.encoderPtr,
                                this.sampleRate,
                                this.channels,
                                application
                            );

                            if (err < 0) {
                                throw new Error(`Opus编码器初始化失败: ${err}`);
                            }

                            // 设置位率 (16kbps)
                            mod._opus_encoder_ctl(this.encoderPtr, 4002, 16000); // OPUS_SET_BITRATE

                            // 设置复杂度 (0-10, 越高质量越好但CPU使用越多)
                            mod._opus_encoder_ctl(this.encoderPtr, 4010, 5);     // OPUS_SET_COMPLEXITY

                            // 设置使用DTX (不传输静音帧)
                            mod._opus_encoder_ctl(this.encoderPtr, 4016, 1);     // OPUS_SET_DTX

                            log("Opus编码器初始化成功", 'success');
                            return true;
                        } catch (error) {
                            if (this.encoderPtr) {
                                mod._free(this.encoderPtr);
                                this.encoderPtr = null;
                            }
                            log(`Opus编码器初始化失败: ${error.message}`, 'error');
                            return false;
                        }
                    },

                    // 编码PCM数据为Opus
                    encode: function (pcmData) {
                        if (!this.encoderPtr) {
                            if (!this.init()) {
                                return null;
                            }
                        }

                        try {
                            const mod = this.module;

                            // 为PCM数据分配内存
                            const pcmPtr = mod._malloc(pcmData.length * 2); // 2字节/int16

                            // 将PCM数据复制到HEAP
                            for (let i = 0; i < pcmData.length; i++) {
                                mod.HEAP16[(pcmPtr >> 1) + i] = pcmData[i];
                            }

                            // 为输出分配内存
                            const outPtr = mod._malloc(this.maxPacketSize);

                            // 进行编码
                            const encodedLen = mod._opus_encode(
                                this.encoderPtr,
                                pcmPtr,
                                this.frameSize,
                                outPtr,
                                this.maxPacketSize
                            );

                            if (encodedLen < 0) {
                                throw new Error(`Opus编码失败: ${encodedLen}`);
                            }

                            // 复制编码后的数据
                            const opusData = new Uint8Array(encodedLen);
                            for (let i = 0; i < encodedLen; i++) {
                                opusData[i] = mod.HEAPU8[outPtr + i];
                            }

                            // 释放内存
                            mod._free(pcmPtr);
                            mod._free(outPtr);

                            return opusData;
                        } catch (error) {
                            log(`Opus编码出错: ${error.message}`, 'error');
                            return null;
                        }
                    },

                    // 销毁编码器
                    destroy: function () {
                        if (this.encoderPtr) {
                            this.module._free(this.encoderPtr);
                            this.encoderPtr = null;
                        }
                    }
                };

                const result = opusEncoder.init();
                return result;
            } catch (error) {
                log(`创建Opus编码器失败: ${error.message}`, 'error');
                return false;
            }
        }

        // 初始化应用
        function initApp() {
            initVisualizer();
            initEventListeners();

            // 检查libopus.js是否正确加载
            checkOpusLoaded();

            // 初始化Opus编码器
            initOpusEncoder();

            // 预加载Opus解码器
            log('预加载Opus解码器...', 'info');
            initOpusDecoder().then(() => {
                log('Opus解码器预加载成功', 'success');
            }).catch(error => {
                log(`Opus解码器预加载失败: ${error.message}，将在需要时重试`, 'warning');
            });

            // 解析欢迎消息的Markdown内容
            const welcomeMessageContent = document.querySelector('.welcome-message .message-content');
            if (welcomeMessageContent) {
                try {
                    const originalText = welcomeMessageContent.textContent;
                    welcomeMessageContent.innerHTML = marked.parse(originalText);
                } catch (error) {
                    log(`欢迎消息Markdown解析失败: ${error.message}`, 'warning');
                }
            }

            // 绑定清空聊天记录按钮事件
            const clearChatBtn = document.getElementById('clearChatBtn');
            if (clearChatBtn) {
                clearChatBtn.addEventListener('click', clearChatHistory);
            }

            // 自动连接到服务器
            setTimeout(() => {
                log('正在自动连接到服务器...', 'info');
                connectToServer();
            }, 2000); // 延迟2秒后自动连接，确保初始化完成
        }

        // PCM录音处理器代码 - 会被注入到AudioWorklet中
        const audioProcessorCode = `
            class AudioRecorderProcessor extends AudioWorkletProcessor {
                constructor() {
                    super();
                    this.buffers = [];
                    this.frameSize = 960; // 60ms @ 16kHz = 960 samples
                    this.buffer = new Int16Array(this.frameSize);
                    this.bufferIndex = 0;
                    this.isRecording = false;

                    // 监听来自主线程的消息
                    this.port.onmessage = (event) => {
                        if (event.data.command === 'start') {
                            this.isRecording = true;
                            this.port.postMessage({ type: 'status', status: 'started' });
                        } else if (event.data.command === 'stop') {
                            this.isRecording = false;

                            // 发送剩余的缓冲区
                            if (this.bufferIndex > 0) {
                                const finalBuffer = this.buffer.slice(0, this.bufferIndex);
                                this.port.postMessage({
                                    type: 'buffer',
                                    buffer: finalBuffer
                                });
                                this.bufferIndex = 0;
                            }

                            this.port.postMessage({ type: 'status', status: 'stopped' });
                        }
                    };
                }

                process(inputs, outputs, parameters) {
                    if (!this.isRecording) return true;

                    const input = inputs[0][0]; // 获取第一个输入通道
                    if (!input) return true;

                    // 将浮点采样转换为16位整数并存储
                    for (let i = 0; i < input.length; i++) {
                        if (this.bufferIndex >= this.frameSize) {
                            // 缓冲区已满，发送给主线程并重置
                            this.port.postMessage({
                                type: 'buffer',
                                buffer: this.buffer.slice(0)
                            });
                            this.bufferIndex = 0;
                        }

                        // 转换为16位整数 (-32768到32767)
                        this.buffer[this.bufferIndex++] = Math.max(-32768, Math.min(32767, Math.floor(input[i] * 32767)));
                    }

                    return true;
                }
            }

            registerProcessor('audio-recorder-processor', AudioRecorderProcessor);
        `;

        // 创建音频处理器
        async function createAudioProcessor() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000,
                    latencyHint: 'interactive'
                });
            }

            try {
                // 检查是否支持AudioWorklet
                if (audioContext.audioWorklet) {
                    // 注册音频处理器
                    const blob = new Blob([audioProcessorCode], { type: 'application/javascript' });
                    const url = URL.createObjectURL(blob);
                    await audioContext.audioWorklet.addModule(url);
                    URL.revokeObjectURL(url);

                    // 创建音频处理节点
                    const audioProcessor = new AudioWorkletNode(audioContext, 'audio-recorder-processor');

                    // 设置音频处理消息处理
                    audioProcessor.port.onmessage = (event) => {
                        if (event.data.type === 'buffer') {
                            // 收到PCM缓冲区数据
                            processPCMBuffer(event.data.buffer);
                        }
                    };

                    log('使用AudioWorklet处理音频', 'success');
                    return { node: audioProcessor, type: 'worklet' };
                } else {
                    // 使用旧版ScriptProcessorNode作为回退方案
                    log('AudioWorklet不可用，使用ScriptProcessorNode作为回退方案', 'warning');

                    const frameSize = 4096; // ScriptProcessorNode缓冲区大小
                    const scriptProcessor = audioContext.createScriptProcessor(frameSize, 1, 1);

                    // 将audioProcess事件设置为处理音频数据
                    scriptProcessor.onaudioprocess = (event) => {
                        if (!isRecording) return;

                        const input = event.inputBuffer.getChannelData(0);
                        const buffer = new Int16Array(input.length);

                        // 将浮点数据转换为16位整数
                        for (let i = 0; i < input.length; i++) {
                            buffer[i] = Math.max(-32768, Math.min(32767, Math.floor(input[i] * 32767)));
                        }

                        // 处理PCM数据
                        processPCMBuffer(buffer);
                    };

                    // 需要连接输出，否则不会触发处理
                    // 我们创建一个静音通道
                    const silent = audioContext.createGain();
                    silent.gain.value = 0;
                    scriptProcessor.connect(silent);
                    silent.connect(audioContext.destination);

                    return { node: scriptProcessor, type: 'processor' };
                }
            } catch (error) {
                log(`创建音频处理器失败: ${error.message}，尝试回退方案`, 'error');

                // 最后回退方案：使用ScriptProcessorNode
                try {
                    const frameSize = 4096; // ScriptProcessorNode缓冲区大小
                    const scriptProcessor = audioContext.createScriptProcessor(frameSize, 1, 1);

                    scriptProcessor.onaudioprocess = (event) => {
                        if (!isRecording) return;

                        const input = event.inputBuffer.getChannelData(0);
                        const buffer = new Int16Array(input.length);

                        for (let i = 0; i < input.length; i++) {
                            buffer[i] = Math.max(-32768, Math.min(32767, Math.floor(input[i] * 32767)));
                        }

                        processPCMBuffer(buffer);
                    };

                    const silent = audioContext.createGain();
                    silent.gain.value = 0;
                    scriptProcessor.connect(silent);
                    silent.connect(audioContext.destination);

                    log('使用ScriptProcessorNode作为回退方案成功', 'warning');
                    return { node: scriptProcessor, type: 'processor' };
                } catch (fallbackError) {
                    log(`回退方案也失败: ${fallbackError.message}`, 'error');
                    return null;
                }
            }
        }

        // 初始化直接从PCM数据录音的系统
        let audioProcessor = null;
        let audioProcessorType = null;
        let audioSource = null;

        // 处理PCM缓冲数据
        let pcmDataBuffer = new Int16Array();
        function processPCMBuffer(buffer) {
            if (!isRecording) return;

            // 将新的PCM数据追加到缓冲区
            const newBuffer = new Int16Array(pcmDataBuffer.length + buffer.length);
            newBuffer.set(pcmDataBuffer);
            newBuffer.set(buffer, pcmDataBuffer.length);
            pcmDataBuffer = newBuffer;

            // 检查是否有足够的数据进行Opus编码（16000Hz, 60ms = 960个采样点）
            const samplesPerFrame = 960; // 60ms @ 16kHz

            while (pcmDataBuffer.length >= samplesPerFrame) {
                // 从缓冲区取出一帧数据
                const frameData = pcmDataBuffer.slice(0, samplesPerFrame);
                pcmDataBuffer = pcmDataBuffer.slice(samplesPerFrame);

                // 编码为Opus
                encodeAndSendOpus(frameData);
            }
        }

        // 编码并发送Opus数据
        function encodeAndSendOpus(pcmData = null) {
            if (!opusEncoder) {
                log('Opus编码器未初始化', 'error');
                return;
            }

            try {
                // 如果提供了PCM数据，则编码该数据
                if (pcmData) {
                    // 使用已初始化的Opus编码器编码
                    const opusData = opusEncoder.encode(pcmData);

                    if (opusData && opusData.length > 0) {
                        // 存储音频帧
                        audioBuffers.push(opusData.buffer);
                        totalAudioSize += opusData.length;

                        // 如果WebSocket已连接，则发送数据
                        if (websocket && websocket.readyState === WebSocket.OPEN) {
                            try {
                                // 服务端期望接收原始Opus数据，不需要任何额外包装
                                websocket.send(opusData.buffer);
                                log(`发送Opus帧，大小：${opusData.length}字节`, 'debug');
                            } catch (error) {
                                log(`WebSocket发送错误: ${error.message}`, 'error');
                            }
                        }
                    } else {
                        log('Opus编码失败，无有效数据返回', 'error');
                    }
                } else {
                    // 处理剩余的PCM数据
                    if (pcmDataBuffer.length > 0) {
                        // 如果剩余的采样点不足一帧，用静音填充
                        const samplesPerFrame = 960;
                        if (pcmDataBuffer.length < samplesPerFrame) {
                            const paddedBuffer = new Int16Array(samplesPerFrame);
                            paddedBuffer.set(pcmDataBuffer);
                            // 剩余部分为0（静音）
                            encodeAndSendOpus(paddedBuffer);
                        } else {
                            encodeAndSendOpus(pcmDataBuffer.slice(0, samplesPerFrame));
                        }
                        pcmDataBuffer = new Int16Array(0);
                    }
                }
            } catch (error) {
                log(`Opus编码错误: ${error.message}`, 'error');
            }
        }

        // 开始直接从PCM数据录音
        async function startDirectRecording() {
            if (isRecording) return;

            try {
                // 初始化Opus编码器
                if (!initOpusEncoder()) {
                    log('无法启动录音: Opus编码器初始化失败', 'error');
                    return;
                }

                // 请求麦克风权限
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 16000,
                        channelCount: 1
                    }
                });

                // 创建音频上下文和分析器
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000,
                        latencyHint: 'interactive'
                    });
                }

                // 创建音频处理器
                const processorResult = await createAudioProcessor();
                if (!processorResult) {
                    log('无法创建音频处理器', 'error');
                    return;
                }

                audioProcessor = processorResult.node;
                audioProcessorType = processorResult.type;

                // 连接音频处理链
                audioSource = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;

                audioSource.connect(analyser);
                audioSource.connect(audioProcessor);

                // 启动录音
                pcmDataBuffer = new Int16Array();
                audioBuffers = [];
                totalAudioSize = 0;
                isRecording = true;

                // 启动音频处理器的录音 - 只有AudioWorklet才需要发送消息
                if (audioProcessorType === 'worklet' && audioProcessor.port) {
                    audioProcessor.port.postMessage({ command: 'start' });
                }

                // 发送监听开始消息
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    // 使用与服务端期望的listen消息格式
                    const listenMessage = {
                        type: 'listen',
                        mode: 'manual',  // 使用手动模式，由我们控制开始/停止
                        state: 'start'   // 表示开始录音
                    };

                    log(`发送录音开始消息: ${JSON.stringify(listenMessage)}`, 'info');
                    websocket.send(JSON.stringify(listenMessage));
                } else {
                    log('WebSocket未连接，无法发送开始消息', 'error');
                    return false;
                }

                // 开始音频可视化
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                drawVisualizer(dataArray);

                // 在UI上显示录音计时器
                let recordingSeconds = 0;
                const recordingTimer = setInterval(() => {
                    recordingSeconds += 0.1;
                    recordButton.innerHTML = `<span style="font-size: 0.7rem; line-height: 1.1;">停止<br>${recordingSeconds.toFixed(1)}秒</span>`;
                }, 100);

                // 保存计时器，以便在停止时清除
                window.recordingTimer = recordingTimer;

                recordButton.classList.add('recording');
                recordButton.disabled = false;

                log('开始PCM直接录音', 'success');
                return true;
            } catch (error) {
                log(`直接录音启动错误: ${error.message}`, 'error');
                isRecording = false;
                return false;
            }
        }

        // 停止直接从PCM数据录音
        function stopDirectRecording() {
            if (!isRecording) return;

            try {
                // 停止录音
                isRecording = false;

                // 停止音频处理器的录音
                if (audioProcessor) {
                    // 只有AudioWorklet才需要发送停止消息
                    if (audioProcessorType === 'worklet' && audioProcessor.port) {
                        audioProcessor.port.postMessage({ command: 'stop' });
                    }

                    audioProcessor.disconnect();
                    audioProcessor = null;
                }

                // 断开音频连接
                if (audioSource) {
                    audioSource.disconnect();
                    audioSource = null;
                }

                // 停止可视化
                if (visualizationRequest) {
                    cancelAnimationFrame(visualizationRequest);
                    visualizationRequest = null;
                }

                // 清除录音计时器
                if (window.recordingTimer) {
                    clearInterval(window.recordingTimer);
                    window.recordingTimer = null;
                }

                // 编码并发送剩余的数据
                encodeAndSendOpus();

                // 发送一个空的消息作为结束标志（模拟接收到空音频数据的情况）
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    // 使用空的Uint8Array发送最后一个空帧
                    const emptyOpusFrame = new Uint8Array(0);
                    websocket.send(emptyOpusFrame);

                    // 发送监听结束消息
                    const stopMessage = {
                        type: 'listen',
                        mode: 'manual',
                        state: 'stop'
                    };

                    websocket.send(JSON.stringify(stopMessage));
                    log('已发送录音停止信号', 'info');
                }

                // 重置UI
                recordButton.innerHTML = '<span style="font-size: 0.75rem;">开始</span>';
                recordButton.classList.remove('recording');
                recordButton.disabled = false;

                log('停止PCM直接录音', 'success');
                return true;
            } catch (error) {
                log(`直接录音停止错误: ${error.message}`, 'error');
                return false;
            }
        }

        async function handleBinaryMessage(data) {
            try {
                let arrayBuffer;

                // 根据数据类型进行处理
                if (data instanceof ArrayBuffer) {
                    arrayBuffer = data;
                    log(`收到ArrayBuffer音频数据，大小: ${data.byteLength}字节`, 'debug');
                } else if (data instanceof Blob) {
                    // 如果是Blob类型，转换为ArrayBuffer
                    arrayBuffer = await data.arrayBuffer();
                    log(`收到Blob音频数据，大小: ${arrayBuffer.byteLength}字节`, 'debug');
                } else {
                    log(`收到未知类型的二进制数据: ${typeof data}`, 'warning');
                    return;
                }

                // 创建Uint8Array用于处理
                const opusData = new Uint8Array(arrayBuffer);

                if (opusData.length > 0) {
                    // 检查当前输入模式，只有在语音输入模式下才处理音频数据
                    const currentMode = getCurrentInputMode();
                    if (currentMode === 'voice') {
                        // 将数据添加到缓冲队列
                        audioBufferQueue.push(opusData);

                        // 如果收到的是第一个音频包，开始缓冲过程
                        if (audioBufferQueue.length === 1 && !isAudioBuffering && !isAudioPlaying) {
                            startAudioBuffering();
                        }
                    } else {
                        // 文本输入模式下忽略音频数据
                        log('文本输入模式，忽略音频数据', 'debug');
                    }
                } else {
                    log('收到空音频数据帧，可能是结束标志', 'warning');

                    // 如果缓冲队列中有数据且没有在播放，检查当前输入模式后决定是否播放
                    if (audioBufferQueue.length > 0 && !isAudioPlaying) {
                        const currentMode = getCurrentInputMode();
                        if (currentMode === 'voice') {
                            playBufferedAudio();
                        } else {
                            log('文本输入模式，暂停音频播放', 'info');
                        }
                    }

                    // 如果正在播放，发送结束信号
                    if (isAudioPlaying && streamingContext) {
                        streamingContext.endOfStream = true;
                    }
                }
            } catch (error) {
                log(`处理二进制消息出错: ${error.message}`, 'error');
            }
        }

        // 获取配置值
        function getConfig() {
            const deviceMac = document.getElementById('deviceMac').value.trim();
            return {
                deviceId: deviceMac,  // 使用MAC地址作为deviceId
                deviceName: document.getElementById('deviceName').value.trim(),
                deviceMac: deviceMac,
                clientId: document.getElementById('clientId').value.trim(),
                token: document.getElementById('token').value.trim()
            };
        }

        // 验证配置
        function validateConfig(config) {
            if (!config.deviceMac) {
                log('设备MAC地址不能为空', 'error');
                return false;
            }
            if (!config.clientId) {
                log('客户端ID不能为空', 'error');
                return false;
            }
            return true;
        }

        initApp();
        
        // 页面加载时加载聊天记录
        loadChatHistory();

        // 动态调整视口高度，解决移动端浏览器地址栏问题
        function setViewportHeight() {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }

        // 初始设置
        setViewportHeight();

        // 监听窗口大小变化
        window.addEventListener('resize', setViewportHeight, { passive: true });
        window.addEventListener('orientationchange', () => {
            setTimeout(setViewportHeight, 100);
        });

        // 移动端特殊处理
        if (/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
            // 监听虚拟键盘显示/隐藏
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    setViewportHeight();
                    // 确保聊天区域不被遮挡
                    const conversationArea = document.getElementById('conversationArea');
                    if (conversationArea) {
                        conversationArea.scrollTop = conversationArea.scrollHeight;
                    }
                }, 150);
            }, { passive: true });
        }

        // 测试麦克风功能
        async function testMicrophone() {
            const resultDiv = document.getElementById('micTestResult');
            resultDiv.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 正在测试麦克风...';
            
            try {
                // 检查浏览器支持
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('您的浏览器不支持麦克风功能');
                }
                
                // 请求麦克风权限
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                // 获取音频轨道
                const audioTracks = stream.getAudioTracks();
                if (audioTracks.length > 0) {
                    const track = audioTracks[0];
                    const settings = track.getSettings();
                    
                    // 显示成功信息
                    resultDiv.innerHTML = `
                        <div style="color: #4CAF50;">
                            <i class="fas fa-check-circle"></i> 麦克风测试成功！<br>
                            <small>
                                设备: ${track.label || '未知设备'}<br>
                                采样率: ${settings.sampleRate || '未知'} Hz<br>
                                通道: ${settings.channelCount || '未知'}<br>
                                回声消除: ${settings.echoCancellation ? '已启用' : '未启用'}<br>
                                降噪: ${settings.noiseSuppression ? '已启用' : '未启用'}
                            </small>
                        </div>
                    `;
                    
                    // 播放测试音频（可选）
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaStreamSource(stream);
                    const analyser = audioContext.createAnalyser();
                    
                    source.connect(analyser);
                    
                    // 简单的音量检测
                    const dataArray = new Uint8Array(analyser.frequencyBinCount);
                    
                    function checkVolume() {
                        analyser.getByteFrequencyData(dataArray);
                        const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                        
                        if (average > 10) {
                            resultDiv.innerHTML += '<br><small style="color: #4CAF50;"><i class="fas fa-volume-up"></i> 检测到声音输入</small>';
                            stream.getTracks().forEach(track => track.stop());
                            return;
                        }
                        
                        if (average < 5) {
                            resultDiv.innerHTML += '<br><small style="color: #FF9800;"><i class="fas fa-volume-mute"></i> 请对着麦克风说话</small>';
                        }
                        
                        setTimeout(checkVolume, 100);
                    }
                    
                    setTimeout(checkVolume, 1000);
                    
                    // 10秒后自动停止
                    setTimeout(() => {
                        stream.getTracks().forEach(track => track.stop());
                        if (resultDiv.innerHTML.indexOf('检测到声音输入') === -1) {
                            resultDiv.innerHTML += '<br><small style="color: #FF5722;"><i class="fas fa-exclamation-triangle"></i> 未检测到声音输入，请检查麦克风</small>';
                        }
                    }, 10000);
                    
                } else {
                    throw new Error('未找到音频设备');
                }
                
            } catch (error) {
                let errorMessage = '';
                
                switch (error.name) {
                    case 'NotAllowedError':
                    case 'PermissionDeniedError':
                        errorMessage = '麦克风权限被拒绝。请在浏览器设置中允许麦克风权限。';
                        break;
                    case 'NotFoundError':
                    case 'DevicesNotFoundError':
                        errorMessage = '未找到麦克风设备。请确保麦克风已连接。';
                        break;
                    case 'NotReadableError':
                    case 'TrackStartError':
                        errorMessage = '麦克风被其他应用占用。请关闭其他使用麦克风的应用。';
                        break;
                    case 'OverconstrainedError':
                    case 'ConstraintNotSatisfiedError':
                        errorMessage = '麦克风不满足要求的约束条件。';
                        break;
                    default:
                        errorMessage = `麦克风测试失败: ${error.message}`;
                }
                
                resultDiv.innerHTML = `
                    <div style="color: #F44336;">
                        <i class="fas fa-times-circle"></i> ${errorMessage}
                    </div>
                `;
            }
        }

    </script>

<!-- 底部导航栏 -->
<div class="bottom-nav">
    <div class="nav-item" data-target="index">
        <div class="nav-icon">
            <i class="fas fa-home"></i>
        </div>
        <div class="nav-label">主页</div>
    </div>
    <div class="nav-item" data-target="orders">
        <div class="nav-icon">
            <i class="fas fa-utensils"></i>
        </div>
        <div class="nav-label">点餐</div>
    </div>
    <div class="nav-item" data-target="repo">
        <div class="nav-icon">
            <i class="fas fa-chart-line"></i>
        </div>
        <div class="nav-label">报告</div>
    </div>
    <div class="nav-item active" data-target="ai-assistant">
        <div class="nav-icon">
            <img src="{% static 'Images/coffee-cup.png' %}" alt="AI助手" style="width: 24px; height: 24px;">
        </div>
        <div class="nav-label">AI助手</div>
    </div>
</div>

<script>
    // 底部导航点击跳转
    document.querySelectorAll('.nav-item').forEach(item => {
        item.addEventListener('click', function () {
            const target = this.getAttribute('data-target');
            let targetUrl = '';
            switch (target) {
                case 'index':
                    targetUrl = "/";
                    break;
                case 'orders':
                    targetUrl = "/orders/";
                    break;
                case 'repo':
                    targetUrl = "/repo/";
                    break;
                case 'ai-assistant':
                    targetUrl = "/ai_health_advisor/";
                    break;
            }
            if (targetUrl) {
                window.location.href = targetUrl;
            }
        });
    });
</script>

        <div class="top-header">
            <div class="header-left">
                <div class="header-logo"><span style="font-size: 24px; font-weight: bold; color: white;">问</span></div>
                <div class="header-title">AI健康顾问</div>
            </div>
            <div class="header-right">
                <div class="header-icon" onclick="document.querySelector('.settings-panel').classList.toggle('open')">
                    <i class="fas fa-cog"></i>
                </div>
            </div>
        </div>
</body>

</html>

